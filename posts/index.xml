<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Raf Rasenberg</title><link>https://vonsopanen.github.io/posts/</link><description>Recent content in Posts on Raf Rasenberg</description><generator>Hugo -- gohugo.io</generator><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 21 Feb 2021 15:07:13 +0100</lastBuildDate><atom:link href="https://vonsopanen.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Deploying FastAPI on AWS as a lambda container image</title><link>https://vonsopanen.github.io/posts/deploying-fastapi-on-aws-as-a-lambda-container-image/</link><pubDate>Sun, 21 Feb 2021 15:07:13 +0100</pubDate><guid>https://vonsopanen.github.io/posts/deploying-fastapi-on-aws-as-a-lambda-container-image/</guid><description>Introduction 📌 Today we are setting up a serverless Lambda container image on AWS running FastAPI. It will be a single Lambda function with an API gateway endpoint attached to it. To handle internal routing we will use the library, Mangum.
Our Docker image will be registered on ECR and we will deploy it using the serverless framework. I&amp;rsquo;m super excited for this blog post since this is an awesome stack, so let&amp;rsquo;s start!</description><content type="html"><![CDATA[<h2 id="introduction-">Introduction 📌</h2>
<p>Today we are setting up a serverless Lambda container image on AWS running FastAPI. It will be a single Lambda function with an API gateway endpoint attached to it. To handle internal routing we will use the library, <a href="https://github.com/jordaneremieff/mangum">Mangum</a>.</p>
<p>Our Docker image will be registered on ECR and we will deploy it using the serverless framework. I&rsquo;m super excited for this blog post since this is an awesome stack, so let&rsquo;s start!</p>
<blockquote>
<p>Article experience level: <strong>Intermediate</strong></p>
</blockquote>
<p>I categorize every article based on complexity. It&rsquo;s a good way to indicate how well you can follow along with the article since it determines how deep I will explain certain concepts.</p>
<p><strong>Prerequisites</strong></p>
<ul>
<li>Docker installed</li>
<li>Serverless framework installed</li>
<li>AWS account</li>
<li>AWS CLI set-up</li>
</ul>
<p>👉 <a href="https://github.com/rafrasenberg/fastapi-lamba-aws">The Github repo for this blog post</a></p>
<h2 id="aws-lambda-container-image-">AWS Lambda container image ☁️</h2>
<p>Last December, AWS announced container support for Lambda functions. What this means is that you can now package and deploy Lambda functions as container images of up to 10GB in size.</p>
<p>This is a really neat feature since you can easily add dependencies without the usage of layers. It also means that you won&rsquo;t have to zip your functions anymore and you can easily add these container builds for your Lambda functions to your CI/CD pipelines. 😄</p>
<p>Just like functions packaged as ZIP archives, functions deployed as container images benefit from the same operational simplicity, automatic scaling, high availability, and native integrations with many services.</p>
<p>Multiple benefits come with running Lambda functions as container images:</p>
<ul>
<li>Better dependency management</li>
<li>Version control (using Docker image tags)</li>
<li>Easy integration into your CI/CD pipeline</li>
<li>Better testing capabilities (run your Lambda runtime locally)</li>
</ul>
<p>Are you convinced? I am! So let&rsquo;s dive into it. 🙌</p>
<h2 id="whats-fastapi">What&rsquo;s FastAPI?</h2>
<p>If you aren&rsquo;t yet familiar with it, FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+, based on standard Python type hints.</p>
<p>It&rsquo;s high performance, on par with NodeJS and Go thanks to the usage of <code>Starlette</code> and <code>Pydantic</code>. It&rsquo;s very easy to write and you need a minimal amount of code to create a robust API. 🚧</p>
<p>Besides that, it comes packed with fully automatic interactive documentation for your API endpoints, which is super neat! Less time writing the API docs, more time coding the actual app.</p>
<h2 id="setting-up-our-workspace">Setting up our workspace</h2>
<p>For this post, I am going to assume that you have an AWS account and that you have set-up your AWS keys in your <code>~./aws</code> directory. Besides that, you&rsquo;ll need <code>serverless</code> and <code>Docker</code> installed as well. So if you haven&rsquo;t already, do that first.</p>
<p>The first thing we are doing is setting up our folder structure and Docker files. To simplify this process or if you are lazy, you can visit the Github repo and fork/clone it.</p>
<p>Make sure your project has the following folders and files. We&rsquo;ll go over each of them and fill them up throughout this post. 🚀</p>
<pre tabindex="0"><code>.
├── compose/
│   ├── dev/
│   │   └── Dockerfile
│   └── prod/
│       └── Dockerfile
├── requirements/
│   ├── dev.txt
│   └── prod.txt
├── app/
│   ├── api_v1/
│   └── main.py
├── serverless.yml
├── functions.yml
└── docker-compose.yml
</code></pre><h2 id="creating-our-dockerfiles">Creating our dockerfiles</h2>
<h4 id="development-container">Development container</h4>
<p>Let&rsquo;s start with our Docker files. What we ideally want is a container for development, in which we will run our FastAPI development server. And then a separate container which will be our production image that will be deployed to AWS. ☁️</p>
<p>For our development container we&rsquo;ll use the Python 3.9 alpine image:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-docker" data-lang="docker"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> python:3.9-alpine</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">WORKDIR</span><span style="color:#e6db74"> /usr/src/app</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> requirements/dev.txt ./<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> python3 -m ensurepip<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> pip install -r dev.txt<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ENV</span> PYTHONPATH <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>PYTHONPATH<span style="color:#e6db74">}</span><span style="color:#e6db74">:/usr/src/app/src&#34;</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;uvicorn&#34;</span>, <span style="color:#e6db74">&#34;src.main:app&#34;</span>, <span style="color:#e6db74">&#34;--host&#34;</span>, <span style="color:#e6db74">&#34;0.0.0.0&#34;</span>, <span style="color:#e6db74">&#34;--port&#34;</span>, <span style="color:#e6db74">&#34;8000&#34;</span>, <span style="color:#e6db74">&#34;--reload&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>It will install our <code>dev</code> requirements, set our Python path inside the container for easy imports, and it will run the FastAPI development server on port 8000.</p>
<p>The dev requirements will contain the following:</p>
<pre tabindex="0"><code>mangum==0.10.0
fastapi==0.63.0
uvicorn==0.13.3

## Add whatever you need in your dev env
# pytest
# coverage
# black
# etc...
</code></pre><p>As you can see we are using Mangum here.</p>
<p>This is an adapter for using ASGI applications with AWS Lambda &amp; API Gateway. It is intended to provide an easy-to-use, configurable wrapper for any ASGI application, deployed in an AWS Lambda function to handle API Gateway requests and responses.</p>
<p>This will allow us to develop our API using FastAPI just as if we would when deploying it on a traditional server. 🔥</p>
<p>You can extend your development container as much as you want, installing all your preferred dev tools and testing frameworks. Since we are locking this into <code>dev.txt</code>, our lambda image for deployment will be nice and slim, containing only the stuff we <strong>really</strong> need in production.</p>
<h4 id="deployment-container">Deployment container</h4>
<p>AWS has certain requirements for the Docker images, so for our deployment container we will use the AWS-Provided base image for Python 3.8</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-docker" data-lang="docker"><span style="color:#66d9ef">FROM</span><span style="color:#e6db74"> public.ecr.aws/lambda/python:3.8</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">COPY</span> requirements/prod.txt <span style="color:#e6db74">${</span>LAMBDA_TASK_ROOT<span style="color:#e6db74">}</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> python3 -m ensurepip<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">RUN</span> pip install -r prod.txt<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">ADD</span> src <span style="color:#e6db74">${</span>LAMBDA_TASK_ROOT<span style="color:#e6db74">}</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#66d9ef">CMD</span> [<span style="color:#e6db74">&#34;main.handler&#34;</span>]<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>Here we copy our files into the <code>LAMBDA_TASK_ROOT</code> which is a runtime environment variable provided by AWS and translates to the path of our Lambda function code.</p>
<p>In the end, we attach our FastAPI handler to the image with <code>main.handler</code>.</p>
<h4 id="docker-compose-file">Docker compose file</h4>
<p>To avoid long and repetitive Docker commands we use docker-compose. Add the following config to your <code>docker-compose.yml</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">version</span>: <span style="color:#e6db74">&#34;3.8&#34;</span>

<span style="color:#f92672">services</span>:
  <span style="color:#f92672">lambda-fastapi-prod</span>:
    <span style="color:#f92672">build</span>:
      <span style="color:#f92672">context</span>: <span style="color:#ae81ff">.</span>
      <span style="color:#f92672">dockerfile</span>: <span style="color:#ae81ff">./compose/prod/Dockerfile</span>
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">&lt;specific-image-name&gt;</span>
    <span style="color:#f92672">container_name</span>: <span style="color:#ae81ff">lambda-fastapi-prod</span>
    <span style="color:#f92672">ports</span>:
      - <span style="color:#ae81ff">9000</span>:<span style="color:#ae81ff">8080</span>

  <span style="color:#f92672">lambda-fastapi-dev</span>:
    <span style="color:#f92672">build</span>:
      <span style="color:#f92672">context</span>: <span style="color:#ae81ff">.</span>
      <span style="color:#f92672">dockerfile</span>: <span style="color:#ae81ff">./compose/dev/Dockerfile</span>
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">lambda-fastapi-dev:latest</span>
    <span style="color:#f92672">container_name</span>: <span style="color:#ae81ff">lambda-fastapi-dev</span>
    <span style="color:#f92672">volumes</span>:
      - <span style="color:#ae81ff">./src:/usr/src/app/src</span>
    <span style="color:#f92672">ports</span>:
      - <span style="color:#ae81ff">8000</span>:<span style="color:#ae81ff">8000</span>
</code></pre></div><p>The <code>image</code> tag for the production container we will fill in later since this needs to be a specific tag so that we can use it with AWS ECR.</p>
<h2 id="create-the-fastapi-server">Create the FastAPI server</h2>
<p>Alright on to the fun part! Let&rsquo;s create our FastAPI server. In <code>src/main.py</code> put the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> fastapi <span style="color:#f92672">import</span> FastAPI
<span style="color:#f92672">from</span> mangum <span style="color:#f92672">import</span> Mangum

app <span style="color:#f92672">=</span> FastAPI(
    title<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;My Awesome FastAPI app&#34;</span>,
    description<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;This is super fancy, with auto docs and everything!&#34;</span>,
    version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0.1.0&#34;</span>,
)


<span style="color:#a6e22e">@app</span><span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;/ping&#34;</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Healthcheck&#34;</span>, tags<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;Healthcheck&#34;</span>])
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">healthcheck</span>():
    <span style="color:#66d9ef">return</span> {<span style="color:#e6db74">&#34;Success&#34;</span>: <span style="color:#e6db74">&#34;Pong!&#34;</span>}


handler <span style="color:#f92672">=</span> Mangum(app)
</code></pre></div><p>Here we create a simple <code>/ping</code> endpoint to test our app with. As you can see, since FastAPI runs on Starlette we can use async Python here! How cool is that. I can see the async king Node.js, crying in the corner already. 😄</p>
<p>As you can see, Mangum wraps around the FastAPI app and is specified as the handler, to allow usage on Lambda.</p>
<h2 id="run-the-development-server">Run the development server</h2>
<p>Time to build our container and run our development server! Within the root directory of your project:</p>
<pre tabindex="0"><code>docker-compose up lambda-fastapi-dev
</code></pre><p>This will build the development container and run it. Here I am specifically not detaching the container so we can use the terminal for debugging purposes since FastAPI will log output there. 💪</p>
<p>The reason we are only running and building our dev container here is because we didn&rsquo;t specify the image tag of our deployment container yet, which we will do later on.</p>
<p>With your image build and FastAPI running in your container, visit <code>localhost:8000/ping</code> to check if everything is working. If all went well, you are greeted with our health check message <code>pong</code>. 🎾</p>
<h4 id="auto-interactive-docs">Auto interactive docs</h4>
<p>A really neat feature that&rsquo;s built into FastAPI, is the interactive auto doc feature. Visit <code>localhost:8000/docs</code> to see it in action.</p>
<p>Try firing the endpoints, you can do it straight from the docs! Awesome right? 😄</p>
<p>You can focus on writing your API code, while FastAPI is taking care of the documenting part. This becomes especially useful when your app scales and you are working with larger, decoupled teams.</p>
<h2 id="using-aws-ecr">Using AWS ECR</h2>
<p>To deploy our Lambda image, we need our container image to be registered at AWS&rsquo;s Elastic Container Registry. From here on I am assuming you have an AWS account with the proper rights, and you have the AWS CLI set-up. If you haven&rsquo;t yet, do that first to continue!</p>
<p>First, we need to create a new ECR repository:</p>
<pre tabindex="0"><code>aws ecr create-repository --repository-name lambda-fastapi --region eu-west-1
</code></pre><p>From the output of this command search for <code>repositoryUri</code>. Note this. In my case this is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#e6db74">&#34;repositoryUri&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> <span style="color:#e6db74">&#34;105477761364.dkr.ecr.eu-west-1.amazonaws.com/lambda-fastapi&#34;</span>
</code></pre></div><p>What we do next is logging into ECR with Docker. Take the first part of the <code>repositoryUri</code> and use that at the end of the command, like below.</p>
<p>For the observant people, yes that&rsquo;s your AWS account number. ECR URLs always follow this same structure: <code>&lt;account-number&gt;.dkr.ecr.&lt;your-region&gt;.amazonaws.com</code>.</p>
<pre tabindex="0"><code>aws ecr get-login-password --region eu-west-1 | docker login --username AWS --password-stdin 105477761364.dkr.ecr.eu-west-1.amazonaws.com
</code></pre><h4 id="building-our-production-image">Building our production image</h4>
<p>Alright, with that out of the way, let&rsquo;s go back to our <code>docker-compose.yml</code> and add the image tag for the production container.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">---
<span style="color:#f92672">services</span>:
  <span style="color:#f92672">lambda-fastapi-prod</span>:
    <span style="color:#f92672">build</span>:
      <span style="color:#f92672">context</span>: <span style="color:#ae81ff">.</span>
      <span style="color:#f92672">dockerfile</span>: <span style="color:#ae81ff">./compose/prod/Dockerfile</span>
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">105477761364.</span><span style="color:#ae81ff">dkr.ecr.eu-west-1.amazonaws.com/lambda-fastapi:latest</span>
    <span style="color:#f92672">container_name</span>: <span style="color:#ae81ff">lambda-fastapi-prod</span>
    <span style="color:#f92672">ports</span>:
      - <span style="color:#ae81ff">9000</span>:<span style="color:#ae81ff">8080</span>
</code></pre></div><p>As you can see, we use the ECR repository name here, attached with a tag <code>:latest</code>. This is just basic Docker tagging and allows for easy version control. You can, of course, change that to whatever suits you.</p>
<p>Now time to build our container:</p>
<pre tabindex="0"><code>docker-compose up --build
</code></pre><p>This will build both containers and run them. I hear you thinking now. With my container running in the background;</p>
<p><em>Would it be possible?</em><br>
<em>Can I invoke my production container locally?</em></p>
<p>Yes, you can! 🚀</p>
<p>To make that work, we need to mimic an AWS API gateway event.</p>
<pre tabindex="0"><code>curl -XPOST &quot;http://localhost:9000/2015-03-31/functions/function/invocations&quot; -d '{
    &quot;resource&quot;: &quot;/local-testing&quot;,
    &quot;path&quot;: &quot;/ping&quot;,
    &quot;httpMethod&quot;: &quot;GET&quot;,
    &quot;headers&quot;: {
      &quot;Accept&quot;: &quot;*/*&quot;,
      &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,
      &quot;cache-control&quot;: &quot;no-cache&quot;,
      &quot;CloudFront-Forwarded-Proto&quot;: &quot;https&quot;,
      &quot;CloudFront-Is-Desktop-Viewer&quot;: &quot;true&quot;,
      &quot;CloudFront-Is-Mobile-Viewer&quot;: &quot;false&quot;,
      &quot;CloudFront-Is-SmartTV-Viewer&quot;: &quot;false&quot;,
      &quot;CloudFront-Is-Tablet-Viewer&quot;: &quot;false&quot;,
      &quot;CloudFront-Viewer-Country&quot;: &quot;US&quot;,
      &quot;Content-Type&quot;: &quot;application/json&quot;,
      &quot;headerName&quot;: &quot;headerValue&quot;,
      &quot;Host&quot;: &quot;gy415nuibc.execute-api.us-east-1.amazonaws.com&quot;,
      &quot;Postman-Token&quot;: &quot;9f583ef0-ed83-4a38-aef3-eb9ce3f7a57f&quot;,
      &quot;User-Agent&quot;: &quot;PostmanRuntime/2.4.5&quot;,
      &quot;Via&quot;: &quot;1.1 d98420743a69852491bbdea73f7680bd.cloudfront.net (CloudFront)&quot;,
      &quot;X-Amz-Cf-Id&quot;: &quot;pn-PWIJc6thYnZm5P0NMgOUglL1DYtl0gdeJky8tqsg8iS_sgsKD1A==&quot;,
      &quot;X-Forwarded-For&quot;: &quot;54.240.196.186, 54.182.214.83&quot;,
      &quot;X-Forwarded-Port&quot;: &quot;443&quot;,
      &quot;X-Forwarded-Proto&quot;: &quot;https&quot;
    },
    &quot;multiValueHeaders&quot;:{
      &quot;Accept&quot;:[
        &quot;*/*&quot;
      ],
      &quot;Accept-Encoding&quot;:[
        &quot;gzip, deflate&quot;
      ],
      &quot;cache-control&quot;:[
        &quot;no-cache&quot;
      ],
      &quot;CloudFront-Forwarded-Proto&quot;:[
        &quot;https&quot;
      ],
      &quot;CloudFront-Is-Desktop-Viewer&quot;:[
        &quot;true&quot;
      ],
      &quot;CloudFront-Is-Mobile-Viewer&quot;:[
        &quot;false&quot;
      ],
      &quot;CloudFront-Is-SmartTV-Viewer&quot;:[
        &quot;false&quot;
      ],
      &quot;CloudFront-Is-Tablet-Viewer&quot;:[
        &quot;false&quot;
      ],
      &quot;CloudFront-Viewer-Country&quot;:[
        &quot;US&quot;
      ],
      &quot;&quot;:[
        &quot;&quot;
      ],
      &quot;Content-Type&quot;:[
        &quot;application/json&quot;
      ],
      &quot;headerName&quot;:[
        &quot;headerValue&quot;
      ],
      &quot;Host&quot;:[
        &quot;gy415nuibc.execute-api.us-east-1.amazonaws.com&quot;
      ],
      &quot;Postman-Token&quot;:[
        &quot;9f583ef0-ed83-4a38-aef3-eb9ce3f7a57f&quot;
      ],
      &quot;User-Agent&quot;:[
        &quot;PostmanRuntime/2.4.5&quot;
      ],
      &quot;Via&quot;:[
        &quot;1.1 d98420743a69852491bbdea73f7680bd.cloudfront.net (CloudFront)&quot;
      ],
      &quot;X-Amz-Cf-Id&quot;:[
        &quot;pn-PWIJc6thYnZm5P0NMgOUglL1DYtl0gdeJky8tqsg8iS_sgsKD1A==&quot;
      ],
      &quot;X-Forwarded-For&quot;:[
        &quot;54.240.196.186, 54.182.214.83&quot;
      ],
      &quot;X-Forwarded-Port&quot;:[
        &quot;443&quot;
      ],
      &quot;X-Forwarded-Proto&quot;:[
        &quot;https&quot;
      ]
    },
    &quot;queryStringParameters&quot;: {
    },
    &quot;multiValueQueryStringParameters&quot;:{
    },
    &quot;pathParameters&quot;: {
    },
    &quot;stageVariables&quot;: {
      &quot;stageVariableName&quot;: &quot;stageVariableValue&quot;
    },
    &quot;requestContext&quot;: {
      &quot;accountId&quot;: &quot;12345678912&quot;,
      &quot;resourceId&quot;: &quot;roq9wj&quot;,
      &quot;stage&quot;: &quot;testStage&quot;,
      &quot;requestId&quot;: &quot;deef4878-7910-11e6-8f14-25afc3e9ae33&quot;,
      &quot;identity&quot;: {
        &quot;cognitoIdentityPoolId&quot;: null,
        &quot;accountId&quot;: null,
        &quot;cognitoIdentityId&quot;: null,
        &quot;caller&quot;: null,
        &quot;apiKey&quot;: null,
        &quot;sourceIp&quot;: &quot;192.168.196.186&quot;,
        &quot;cognitoAuthenticationType&quot;: null,
        &quot;cognitoAuthenticationProvider&quot;: null,
        &quot;userArn&quot;: null,
        &quot;userAgent&quot;: &quot;PostmanRuntime/2.4.5&quot;,
        &quot;user&quot;: null
      },
      &quot;resourcePath&quot;: &quot;/ping&quot;,
      &quot;httpMethod&quot;: &quot;GET&quot;,
      &quot;apiId&quot;: &quot;gy415nuibc&quot;
    },
    &quot;body&quot;: &quot;{}&quot;,
    &quot;isBase64Encoded&quot;: false
}'
</code></pre><p>Output:</p>
<pre tabindex="0"><code>{&quot;isBase64Encoded&quot;: false, &quot;statusCode&quot;: 200, &quot;headers&quot;: {&quot;content-length&quot;: &quot;19&quot;, &quot;content-type&quot;: &quot;application/json&quot;}, &quot;body&quot;: &quot;{\&quot;Success\&quot;:\&quot;Pong!\&quot;}&quot;}%
</code></pre><p>That&rsquo;s absolutely insane! 🔥 We can invoke our Lambda function locally, just as how it would run on AWS itself.</p>
<p>The only things you need to adjust in the event are the <code>httpMethod</code> and the <code>path</code> and <code>resourcePath</code>. You can test every event locally, even <code>POST</code> and <code>PUT</code> requests, by adding a <code>body</code> to it.</p>
<p>The potential of this is huge, because you can easily incorporate integration tests for your Lambda functions now. After all, it runs against the actual Lambda runtime. No more mocking! 👌</p>
<h2 id="deploying-our-lambda-container">Deploying our Lambda container</h2>
<p>Next up, is deploying our container image. Let&rsquo;s first start with pushing our locally build image to ECR.</p>
<pre tabindex="0"><code>docker push 105477761364.dkr.ecr.eu-west-1.amazonaws.com/lambda-fastapi:latest
</code></pre><p>Here you would obviously, use the same url as how you tagged your image and build it. We get our output back:</p>
<pre tabindex="0"><code>latest: digest: sha256:23ea6742e439757b0d331f08c461b0146bd1a6e0796f7dd388ae86abadf54c19 size: 2413
</code></pre><p>Note the digest output, we will use it in our serverless configuration to deploy our Lambda.</p>
<p>With our FastAPI lambda container deployed on ECR, let&rsquo;s create our <code>serverless.yml</code> file and deploy the API gateway that we will use to invoke our Lambda.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">service</span>: <span style="color:#ae81ff">lambda-fastapi</span>

<span style="color:#f92672">frameworkVersion</span>: <span style="color:#e6db74">&#34;2&#34;</span>

<span style="color:#f92672">provider</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">aws</span>
  <span style="color:#f92672">stage</span>: <span style="color:#ae81ff">${opt:stage}</span>
  <span style="color:#f92672">region</span>: <span style="color:#ae81ff">eu-west-1</span>
  <span style="color:#f92672">lambdaHashingVersion</span>: <span style="color:#ae81ff">20201221</span>
  <span style="color:#f92672">memorySize</span>: <span style="color:#ae81ff">256</span>
  <span style="color:#f92672">timeout</span>: <span style="color:#ae81ff">30</span>
  <span style="color:#f92672">apiName</span>: <span style="color:#ae81ff">${self:service}-${opt:stage}</span>
  <span style="color:#f92672">apiGateway</span>:
    <span style="color:#f92672">description</span>: <span style="color:#ae81ff">REST API ${self:service}</span>
    <span style="color:#f92672">metrics</span>: <span style="color:#66d9ef">true</span>

<span style="color:#f92672">functions</span>: <span style="color:#ae81ff">${file(functions.yml):functions}</span>
</code></pre></div><p>Now add the function in <code>functions.yml</code>. Take a good look at the image URL we use here, it follows the following format: <code>&lt;your-ecr-repo&gt;@&lt;your-digest&gt;</code>.</p>
<p>Use the digest output here that you noted earlier after the ECR push.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">functions</span>:
  <span style="color:#f92672">myAwesomeFastAPIFunction</span>:
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">105477761364.</span><span style="color:#ae81ff">dkr.ecr.eu-west-1.amazonaws.com/lambda-fastapi@sha256:23ea6742e439757b0d331f08c461b0146bd1a6e0796f7dd388ae86abadf54c19</span>
    <span style="color:#f92672">events</span>:
      - <span style="color:#f92672">http</span>:
          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">ping/</span>
          <span style="color:#f92672">method</span>: <span style="color:#ae81ff">get</span>
          <span style="color:#f92672">cors</span>: <span style="color:#66d9ef">true</span>
</code></pre></div><p>Time to deploy our Lambda! 🚀</p>
<pre tabindex="0"><code>serverless deploy --stage dev
</code></pre><p>Output:</p>
<pre tabindex="0"><code>Service Information
service: lambda-fastapi
stage: dev
region: eu-west-1
stack: lambda-fastapi-dev
resources: 12
api keys:
  None
endpoints:
  GET - https://119dyojuza.execute-api.eu-west-1.amazonaws.com/dev/ping
functions:
  lambda-fastapi: lambda-fastapi-dev-myAwesomeFastAPIFunction
layers:
  None
</code></pre><p>Visit your endpoint and see the result!</p>
<pre tabindex="0"><code>{&quot;Success&quot;:&quot;Pong!&quot;}
</code></pre><h2 id="extending-the-api">Extending the API</h2>
<p>Alright, that&rsquo;s very cool what we just did, but you might want a little more than just a <code>/ping</code> endpoint. So let&rsquo;s extend our API and truly see the power of Mangum + FastAPI, handling internal routing within a single Lambda container image. 📈</p>
<p>Add the following files to your <code>src</code> folder:</p>
<pre tabindex="0"><code>src
  api_v1/
    users/
      users.py
    api.py
  main.py
</code></pre><p>As you can see, we can really structure our app very well, by using FastAPI&rsquo;s nested routing. This makes our app look clean and keeps our code separated. You could make multiple modules for different parts of your API.</p>
<p>In our <code>api.py</code> file, add the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> fastapi <span style="color:#f92672">import</span> APIRouter

<span style="color:#f92672">from</span> .users <span style="color:#f92672">import</span> users

router <span style="color:#f92672">=</span> APIRouter()

router<span style="color:#f92672">.</span>include_router(users<span style="color:#f92672">.</span>router, prefix<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/users&#34;</span>, tags<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;Users&#34;</span>])
</code></pre></div><p>Then within our <code>users.py</code> file, add the following routes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> fastapi <span style="color:#f92672">import</span> APIRouter

router <span style="color:#f92672">=</span> APIRouter()


<span style="color:#a6e22e">@router</span><span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;/</span><span style="color:#e6db74">{id}</span><span style="color:#e6db74">&#34;</span>)
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_user</span>():
    results <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;Success&#34;</span>: <span style="color:#e6db74">&#34;This is one user!&#34;</span>}
    <span style="color:#66d9ef">return</span> results


<span style="color:#a6e22e">@router</span><span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;/&#34;</span>)
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_users</span>():
    results <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;Success&#34;</span>: <span style="color:#e6db74">&#34;All users!&#34;</span>}
    <span style="color:#66d9ef">return</span> results
</code></pre></div><p>And finally, the last step is adding our new router app to our <code>main.py</code> file which is our Lambda handler as you remember.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> fastapi <span style="color:#f92672">import</span> FastAPI
<span style="color:#f92672">from</span> mangum <span style="color:#f92672">import</span> Mangum
<span style="color:#f92672">from</span> api_v1.api <span style="color:#f92672">import</span> router <span style="color:#66d9ef">as</span> api_router

app <span style="color:#f92672">=</span> FastAPI(
    title<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;My Awesome FastAPI app&#34;</span>,
    description<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;This is super fancy, with auto docs and everything!&#34;</span>,
    version<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0.1.0&#34;</span>,
)


<span style="color:#a6e22e">@app</span><span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#34;/ping&#34;</span>, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Healthcheck&#34;</span>, tags<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;Healthcheck&#34;</span>])
<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">healthcheck</span>():
    <span style="color:#66d9ef">return</span> {<span style="color:#e6db74">&#34;Success&#34;</span>: <span style="color:#e6db74">&#34;Pong!&#34;</span>}

app<span style="color:#f92672">.</span>include_router(api_router, prefix<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/api/v1&#34;</span>)

handler <span style="color:#f92672">=</span> Mangum(app)
</code></pre></div><p>Assuming your development server is still running (this is the beauty of FastAPI development), visit <code>localhost:8000/api/v1/users</code>. It works! Awesome. 🔥</p>
<p>Also, check out <code>/docs</code> to see our newly updated interactive docs:</p>
<p><img src="/images/blog/8/fastapi-docs.png" alt="FastAPI autodocs"></p>
<p>As you can see, our new endpoint is working. Note the prefix we use here <code>/api/v1</code>.</p>
<p>It&rsquo;s always good practice to version your APIs. When your app grows, you might plan on releasing a new API with breaking changes for your end-user. By versioning it, you could just start developing in a new folder <code>api_v2</code> and create a new prefix <code>/api/v2</code> for it. This will give your users time to switch over while slowly deprecating your old API.</p>
<h4 id="rebuild-the-container">Rebuild the container</h4>
<p>Time to rebuild our container, since our code changed. 🚧</p>
<pre tabindex="0"><code>docker-compose build --no-cache lambda-fastapi-prod
</code></pre><p>Now push the new version to ECR, note the digest output again so we can reference that in our <code>serverless</code> file.</p>
<pre tabindex="0"><code>docker push 105477061364.dkr.ecr.eu-west-1.amazonaws.com/lambda-fastapi:latest
</code></pre><h4 id="adding-new-routes">Adding new routes</h4>
<p>With our new container on ECR, add the endpoints to our <code>functions.yml</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">functions</span>:
  <span style="color:#f92672">myAwesomeFastAPIFunction</span>:
    <span style="color:#f92672">image</span>: <span style="color:#ae81ff">105477761364.</span><span style="color:#ae81ff">dkr.ecr.eu-west-1.amazonaws.com/lambda-fastapi@sha256:cc85e1e3b0a862115deee4f151e981c79d5b453fb0645099c6e86a29deeea0e0</span>
    <span style="color:#f92672">events</span>:
      - <span style="color:#f92672">http</span>:
          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">ping/</span>
          <span style="color:#f92672">method</span>: <span style="color:#ae81ff">get</span>
          <span style="color:#f92672">cors</span>: <span style="color:#66d9ef">true</span>
      - <span style="color:#f92672">http</span>:
          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">api/v1/users/</span>
          <span style="color:#f92672">method</span>: <span style="color:#ae81ff">any</span>
          <span style="color:#f92672">cors</span>: <span style="color:#66d9ef">true</span>
      - <span style="color:#f92672">http</span>:
          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">api/v1/users/{id}</span>
          <span style="color:#f92672">method</span>: <span style="color:#ae81ff">any</span>
          <span style="color:#f92672">cors</span>: <span style="color:#66d9ef">true</span>
</code></pre></div><p>Make sure you change the digest of your image as well, to the latest one that you just deployed. These kinds of things can of course be automated, making deployment even quicker, but that&rsquo;s not the point of this blog post. You can be creative yourself with that. 😝</p>
<p>Also, something to note, the serverless framework itself does offer a functionality where it will build your Docker container for you, basically not having to paste the new digest for the image or push it to ECR yourself. However, this is quite buggy and I didn&rsquo;t get it to work for me.</p>
<p>This also means that each time you might just want to change an API gateway route, it will rebuild the full container and pushes it to ECR, when that&rsquo;s not needed sometimes. So I prefer to do it this way! Feel free to do whatever works for you of course.</p>
<p>Time to deploy! 🚀</p>
<pre tabindex="0"><code>serverless deploy --stage dev
</code></pre><p>Output:</p>
<pre tabindex="0"><code>Service Information
service: lambda-fastapi
stage: dev
region: eu-west-1
stack: lambda-fastapi-dev
resources: 20
api keys:
  None
endpoints:
  GET - https://119dyojuza.execute-api.eu-west-1.amazonaws.com/dev/ping
  ANY - https://119dyojuza.execute-api.eu-west-1.amazonaws.com/dev/api/v1/users
  ANY - https://119dyojuza.execute-api.eu-west-1.amazonaws.com/dev/api/v1/users/{id}
functions:
  lambda-fastapi: lambda-fastapi-dev-myAwesomeFastAPIFunction
layers:
  None
</code></pre><p>Now visit the <code>users</code> endpoint first. As you can see, we get our response back that we specified: <code>{&quot;Success&quot;:&quot;All users!&quot;}</code></p>
<p>Now let&rsquo;s try our dynamic endpoint by visiting e.g. <code>users/1</code>. Our return will be: <code>{&quot;Success&quot;:&quot;This is one user!&quot;}</code>.</p>
<p>Awesome! As you can see our FastAPI is working perfectly and all internal routing is properly handled.</p>
<h2 id="conclusion-">Conclusion ⚡</h2>
<p>Alright so in this blog post we deployed a FastAPI lambda function on AWS as a container image.</p>
<p>We registered our image on ECR, added multiple internal routes and we deployed it through serverless. Now it&rsquo;s up to you to, of course, to implement the logic behind these API routes. But now you know <em>how</em> to set it up.</p>
<p>I hope you learned enough by now to create container image Lambda APIs on AWS. In the future, I will definitely post some more about it. Maybe integrating our API with various other AWS services like e.g. DynamoDB.</p>
<p>See you next time! 👋</p>
]]></content></item><item><title>Using Traefik as Ingress Controller on a Kubernetes cluster with cert-manager | Part 2</title><link>https://vonsopanen.github.io/posts/using-traefik-as-ingress-controller-on-a-kubernetes-cluster-with-cert-manager-part-2/</link><pubDate>Sun, 22 Nov 2020 06:27:18 +0100</pubDate><guid>https://vonsopanen.github.io/posts/using-traefik-as-ingress-controller-on-a-kubernetes-cluster-with-cert-manager-part-2/</guid><description>Introduction 📌 This is Part 2 of the Kubernetes blog series. In this part, we will deploy and expose the Traefik dashboard to a custom domain. As a bonus, we will deploy a small example application as well.
The domains will be pointed to our external load balancer and we will secure them with Let&amp;rsquo;s Encrypt through cert-manager.
To follow along with this part, please follow Part 1 first.
With that being said, let&amp;rsquo;s deploy some services to our shiny new Kubernetes cluster!</description><content type="html"><![CDATA[<h2 id="introduction-">Introduction 📌</h2>
<p>This is Part 2 of the Kubernetes blog series. In this part, we will deploy and expose the Traefik dashboard to a custom domain. As a bonus, we will deploy a small example application as well.</p>
<p>The domains will be pointed to our external load balancer and we will secure them with Let&rsquo;s Encrypt through cert-manager.</p>
<p>To follow along with this part, please <a href="https://rafrasenberg.com/posts/kubernetes-with-terraform-traefik-v2-cert-manager-part-1/">follow Part 1 first</a>.</p>
<p>With that being said, let&rsquo;s deploy some services to our shiny new Kubernetes cluster! 👏</p>
<blockquote>
<p>Article experience level: <strong>Intermediate</strong></p>
</blockquote>
<p>I categorize every article based on complexity. It&rsquo;s a good way to indicate how well you can follow along with the article since it determines how deep I will explain certain concepts.</p>
<p><strong>Prerequisites</strong></p>
<ul>
<li>Followed <a href="https://rafrasenberg.com/posts/kubernetes-with-terraform-traefik-v2-cert-manager-part-1/">Part 1</a></li>
<li>Domain name</li>
<li>kubectl installed</li>
<li>doctl installed</li>
</ul>
<p>👉 <a href="https://github.com/rafrasenberg/kubernetes-terraform-traefik-cert-manager">The Github repo for this blog post</a></p>
<h2 id="interacting-with-our-kubernetes-cluster">Interacting with our Kubernetes cluster</h2>
<p>In order to interact with our cluster from our local machine, we need <code>kubectl</code> installed.</p>
<p>The Kubernetes command-line tool, <code>kubectl</code>, allows you to run commands against Kubernetes clusters. You can use <code>kubectl</code> to deploy applications, inspect and manage cluster resources, and view logs.</p>
<p>Besides the Kubernetes command-line tool, we also need <code>doctl</code>. This is the official DigitalOcean command-line client. It uses the DigitalOcean API to provide access to most account and Droplet features.</p>
<p>Please follow the docs to install both of these on your machine:</p>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">Install kubectl</a></li>
<li><a href="https://www.digitalocean.com/docs/apis-clis/doctl/how-to/install/">Install doctl</a></li>
</ul>
<p>From this moment on I am assuming that you have successfully installed and configured <code>kubectl</code> and <code>doctl</code>.</p>
<p>When those are installed please visit the Digital Ocean dashboard and go to your cluster. There you will find a command to connect to your cluster, for easy multiple-cluster management.</p>
<p><img src="/images/blog/7/kubernetes-connect-kubectl.png" alt="Kubernetes Cluster Digital Ocean Kubectl"></p>
<p>Paste this command in your terminal and connect your cluster.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ doctl kubernetes cluster kubeconfig save 33d303ec-4b1e-4972-8e9e-670344a64122
</code></pre><p><strong>Output:</strong></p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">Notice: Adding cluster credentials to kubeconfig file found in &quot;/home/raf/.kube/config&quot;
Notice: Setting current-context to do-ams3-my-special-cluster
</code></pre><p>Great. Everything is set-up now.</p>
<h2 id="testing-our-cluster-and-configuration-">Testing our cluster and configuration 👀</h2>
<p>Alright with our Kubernetes cluster successfully connected, let&rsquo;s run some commands to verify if our cluster install went as we expected.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl get nodes
</code></pre><p><strong>Output:</strong></p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">NAME                            STATUS   ROLES    AGE     VERSION
my-special-cluster-pool-3hkcb   Ready    &lt;none&gt;   3h28m   v1.19.3
my-special-cluster-pool-3hkcw   Ready    &lt;none&gt;   3h29m   v1.19.3
</code></pre><p>As you can see, we can interact with our cluster right now through <code>kubectl</code>, so that means we can deploy some services!</p>
<p>In the previous blog post and what you can see back in your Terraform configuration, is that we deployed two services through Helm:</p>
<ul>
<li>Traefik</li>
<li>cert-manager</li>
</ul>
<p>So let&rsquo;s see if they are up and running in our cluster without any errors. Let&rsquo;s check Traefik first.</p>
<p>We use the <code>get svc</code> (shorthand for <code>get services</code>) command to list all services in the default namespace. As you might remember from our Terraform configuration, we created a <code>traefik</code> namespace and deployed the Traefik Helm repository into that. So therefore we will specify the <code>-n</code> namespace flag, to return all services in that namespace.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl get svc -n traefik
</code></pre><p><strong>Output:</strong></p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">NAME      TYPE           CLUSTER-IP       EXTERNAL-IP    PORT(S)                      AGE
traefik   LoadBalancer   10.245.173.208   64.225.81.60   80:31782/TCP,443:31660/TCP   3h31m
</code></pre><p>Awesome! Our Traefik LoadBalancer is successfully running as you can see.</p>
<p>The above output lists the Cluster-IP, the External-IP as well as the target and node-ports the service is running on.</p>
<p>The external IP is the one that is exposed to the outside with the Digital Ocean load balancer behind it. So that will be the IP address where you will be pointing your domain name to.</p>
<p>Now let&rsquo;s quickly go over this again but then for <code>cert-manager</code>.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl get svc -n cert-manager
</code></pre><p><strong>Output:</strong></p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
cert-manager           ClusterIP   10.245.118.110   &lt;none&gt;        9402/TCP   3h44m
cert-manager-webhook   ClusterIP   10.245.145.85    &lt;none&gt;        443/TCP    3h44m
</code></pre><p>As you can see, all is up and running! 🚀</p>
<h2 id="deploying-the-clusterissuer">Deploying the ClusterIssuer</h2>
<p>The first thing we need to do first is deploying the ClusterIssuer that will generate free SSL certificates for us.</p>
<h4 id="what-is-a-clusterissuer">What is a ClusterIssuer?</h4>
<p>Issuers, and ClusterIssuers, are Kubernetes resources that represent certificate authorities (CAs) that are able to generate signed certificates by honoring certificate signing requests. All <code>cert-manager</code> certificates require a referenced issuer that is in a ready condition to attempt to honor the request.</p>
<p>If you want to create a single Issuer that can be consumed in multiple namespaces, you should consider creating a ClusterIssuer resource. This is almost identical to the Issuer resource, however is non-namespaced so it can be used to issue Certificates across all namespaces.</p>
<p>For this, we will be using ClusterIssuer.</p>
<p>Let&rsquo;s create the <code>post-deployment</code> folder and in there a <code>01-cert-manager</code> folder with a <code>01-issuer.yml</code> file:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ mkdir post-deployment/01-cert-manager &amp;&amp; touch post-deployment/01-cert-manager/01-issuer.yml
</code></pre><p>Within the <code>01-issuer.yml</code> file, add this configuration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1alpha2</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">letsencrypt-prod</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">acme</span>:
    <span style="color:#f92672">email</span>: <span style="color:#ae81ff">youremail@gmail.com</span>
    <span style="color:#f92672">server</span>: <span style="color:#ae81ff">https://acme-v02.api.letsencrypt.org/directory</span>
    <span style="color:#f92672">solvers</span>:
      - <span style="color:#f92672">http01</span>:
          <span style="color:#f92672">ingress</span>:
            <span style="color:#f92672">class</span>: <span style="color:#ae81ff">traefik-cert-manager</span>
</code></pre></div><p>Please make sure you modify the email, this has to be a valid one.</p>
<p>As you can see from the configuration, we are using a <code>http01</code> solver here. <code>cert-manager</code> offers two methods of validation:</p>
<ul>
<li>DNS Validation</li>
<li>HTTP Validation</li>
</ul>
<p>When working with different kinds of domains, a HTTP01 validation is the easiest. With a HTTP01 challenge, you prove ownership of a domain by ensuring that a particular file is present at the domain. It is assumed that you control the domain if you are able to publish the given file under a given path.</p>
<p>DNS validation on the other hand is very useful when you are working with an organization&rsquo;s domain name and you would like to deploy services on subdomains like so: <code>*.yourdomain.com</code>. You can then generate a wildcard certificate and solve the DNS challenge through services like Cloudflare or AWS Route53.</p>
<p>As you might notice here, you see that the <code>http01</code> ingress class is called <code>traefik-cert-manager</code>. Where did we see that before?</p>
<p>Ah yes! In the custom values file within our Terraform configuration for the Traefik Helm deployment.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">additionalArguments:
  - &quot;--providers.kubernetesIngress.ingressClass=traefik-cert-manager&quot;
</code></pre><p>Now you know what that is for! 😄</p>
<p>Finally, let&rsquo;s deploy our ClusterIssuer through <code>kubectl</code>:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl apply -f post-deployment/01-cert-manager/01-issuer.yml
</code></pre><p>Now with our ClusterIssuer successfully in place, we can start generating certificates for our services.</p>
<h2 id="exposing-the-traefik-dashboard">Exposing the Traefik dashboard</h2>
<p>To access the Traefik dashboard, you will need a domain name pointing to the load balancer&rsquo;s external IP. You can check which IP that is with the <code>kubectl get svc -n traefik</code> command that we explained earlier.</p>
<p>Then in your registrar panel just add an <code>A</code> record pointing to that IP address.</p>
<p>With that done let&rsquo;s create a folder that will hold our certificates and in there the certificate file for the Traefik dashboard:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ mkdir post-deployment/certificates &amp;&amp; touch post-deployment/certificates/traefik-dashboard.yml
</code></pre><p>Now edit the <code>traefik-dashboard.yml</code> file and add this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1alpha2</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Certificate</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">traefik-dashboard-cert</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">traefik</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">&#34;use-http01-solver&#34;: </span><span style="color:#e6db74">&#34;true&#34;</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">commonName</span>: <span style="color:#ae81ff">traefik.yourdomain.com</span>
  <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">traefik-dashboard-cert</span>
  <span style="color:#f92672">dnsNames</span>:
    - <span style="color:#ae81ff">traefik.yourdomain.com</span>
  <span style="color:#f92672">issuerRef</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">letsencrypt-prod</span>
    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
</code></pre></div><p>Please change the domain/sub-domain name here, to the one you want to use for the Traefik dashboard. If you have done that, run the following command to generate a certificate:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl apply -f post-deployment/certificates/traefik-dashboard.yml
</code></pre><p>Now wait around a minute or 2 and then run the following command to check if your certificate is ready and you didn&rsquo;t run into any errors:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl -n traefik describe certificate traefik-dashboard-cert
</code></pre><p><strong>Output:</strong></p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">...
Status:
  Conditions:
    Last Transition Time:  2020-11-22T10:03:19Z
    Message:               Certificate is up to date and has not expired
    Reason:                Ready
    Status:                True
    Type:                  Ready
  Not After:               2021-02-20T09:03:18Z
  Not Before:              2020-11-22T09:03:18Z
  Renewal Time:            2021-01-21T09:03:18Z
  Revision:                1
Events:
  Type    Reason     Age   From          Message
  ----    ------     ----  ----          -------
  Normal  Issuing    100s  cert-manager  Issuing certificate as Secret does not exist
  Normal  Generated  99s   cert-manager  Stored new private key in temporary Secret resource &quot;traefik-dashboard-cert-dcc7c&quot;
  Normal  Requested  99s   cert-manager  Created new CertificateRequest resource &quot;traefik-dashboard-cert-66zld&quot;
  Normal  Issuing    95s   cert-manager  The certificate has been successfully issued
</code></pre><p>Awesome, all done! Let&rsquo;s now create our Traefik deployment files and register the dashboard as an Ingress route so we can reach it through the specified domain name.</p>
<p>We will create a new folder within our <code>post-deployment</code> folder and add a <code>middleware.yml</code> and <code>ingress.yml</code> file:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ mkdir post-deployment/02-traefik
$ touch post-deployment/02-traefik/01-middleware.yml post-deployment/02-traefik/02-ingress.yml
</code></pre><p>Because the Traefik dashboard is exposed by default, we will add a general Kubernetes secret and a Traefik middleware to create simple basic auth protection.</p>
<p>You can add your own password there of course, by using a tool like <code>htpassword</code>. Traefik supports passwords hashed with MD5, SHA1, or BCrypt.</p>
<p>In <code>middleware.yml</code> add the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Secret</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">traefik-dashboard-auth</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">traefik</span>
<span style="color:#f92672">data</span>:
  <span style="color:#75715e"># Login: raf | 123</span>
  <span style="color:#f92672">users</span>: <span style="color:#ae81ff">cmFmOiRhcHIxJGRiN1VMZzFGJDB6OUFtWUVLaWRTQ0h4RkpxODdGYTEKCg==</span>
---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">traefik.containo.us/v1alpha1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Middleware</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">traefik-dashboard-basicauth</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">traefik</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">basicAuth</span>:
    <span style="color:#f92672">secret</span>: <span style="color:#ae81ff">traefik-dashboard-auth</span>
</code></pre></div><p>Now add the ingress route configuration in <code>02-ingress.yml</code>, of course changing your domain name again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">traefik.containo.us/v1alpha1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">IngressRoute</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">traefik-dashboard</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">traefik</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">entryPoints</span>:
    - <span style="color:#ae81ff">websecure</span>
  <span style="color:#f92672">routes</span>:
    - <span style="color:#f92672">match</span>: <span style="color:#ae81ff">Host(`traefik.yourdomain.com`)</span>
      <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Rule</span>
      <span style="color:#f92672">middlewares</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">traefik-dashboard-basicauth</span>
          <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">traefik</span>
      <span style="color:#f92672">services</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">api@internal</span>
          <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">TraefikService</span>
          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
  <span style="color:#f92672">tls</span>:
    <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">traefik-dashboard-cert</span>
</code></pre></div><h4 id="lets-deploy-">Let&rsquo;s deploy 🚀</h4>
<p>Alright with everything prepared now, let&rsquo;s deploy our Ingress route and expose the Traefik dashboard! By running the command below, <code>kubectl</code> will first apply the middleware and then deploy the ingress route.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl apply -f post-deployment/02-traefik/
</code></pre><p>BOOM! We got it up and running. 🎯</p>
<p>If you follow the domain name you will be greeted with a TLS encrypted route to the Traefik dashboard. After entering the basic auth username and password, the dashboard will be displayed. Awesome!</p>
<p><img src="/images/blog/7/traefik-dashboard-1.png" alt="Traefik Dashboard"></p>
<p>As you can see when you view the HTTP routers, you can see our dashboard route is safely secured with TLS and Traefik recognizes it as a Kubernetes route.</p>
<p><img src="/images/blog/7/traefik-dashboard-2.png" alt="Traefik HTTP Routers"></p>
<h2 id="an-example-application">An example application</h2>
<p>With the dashboard up and running, let&rsquo;s deploy an example <code>whoami</code> application with TLS encryption. The first thing you have to do again, is to add a DNS entry for the <code>whoami</code> service. Then add the appropriate folder and files:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ mkdir post-deployment/03-whoami
$ touch post-deployment/certificates/whoami.yml
$ touch post-deployment/03-whoami/01-whoami.yml post-deployment/03-whoami/02-ingress.yml
</code></pre><p>Time to create a new certificate. So add this to <code>post-deployment/certificates/whoami.yml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">cert-manager.io/v1alpha2</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Certificate</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">whoami-cert</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">whoami</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">&#34;use-http01-solver&#34;: </span><span style="color:#e6db74">&#34;true&#34;</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">commonName</span>: <span style="color:#ae81ff">whoami.rafrasenberg.com</span>
  <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">whoami-cert</span>
  <span style="color:#f92672">dnsNames</span>:
    - <span style="color:#ae81ff">whoami.rafrasenberg.com</span>
  <span style="color:#f92672">issuerRef</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">letsencrypt-prod</span>
    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">ClusterIssuer</span>
</code></pre></div><p>Then add <code>01-whoami.yml</code> inside the <code>post-deployment/03-whoami</code> folder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">whoami</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">whoami</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">whoami</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">whoami</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">containers</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">whoami</span>
          <span style="color:#f92672">image</span>: <span style="color:#ae81ff">containous/whoami</span>
          <span style="color:#f92672">imagePullPolicy</span>: <span style="color:#ae81ff">Always</span>

---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">whoami</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">whoami</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">whoami</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">ClusterIP</span>
  <span style="color:#f92672">ports</span>:
    - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">whoami</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">whoami</span>
</code></pre></div><p>Then add the ingress route in <code>02-ingress.yml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">traefik.containo.us/v1alpha1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">IngressRoute</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">whoami</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">whoami</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">entryPoints</span>:
    - <span style="color:#ae81ff">websecure</span>
  <span style="color:#f92672">routes</span>:
    - <span style="color:#f92672">match</span>: <span style="color:#ae81ff">Host(`whoami.rafrasenberg.com`)</span>
      <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Rule</span>
      <span style="color:#f92672">services</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">whoami</span>
          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
  <span style="color:#f92672">tls</span>:
    <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">whoami-cert</span>
</code></pre></div><p>Alright so before we are generating the certificate again, don&rsquo;t forget to create the <code>whoami</code> namespace, since we are deploying to that and it isn&rsquo;t there yet.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl create namespace whoami
</code></pre><p>Then generate our certificate again:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl apply -f post-deployment/certificates/whoami.yml
</code></pre><p>Wait for some time and see if it is successfully issued:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl -n whoami describe certificate whoami-cert
</code></pre><p>If everything thing went well and your certificate was successfully issued, deploy the <code>whoami</code> service:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ kubectl apply -f post-deployment/03-whoami/
</code></pre><p>Great work! 🔥 As you can see, the <code>whoami</code> service is available through the domain name, running over TLS:</p>
<p><img src="/images/blog/7/whoami-service.png" alt="Whoami Service"></p>
<p>You can see the service in the Traefik dashboard now as well:</p>
<p><img src="/images/blog/7/traefik-dashboard-3.png" alt="Whoami Service in Traefik dashboard"></p>
<h2 id="conclusion-">Conclusion ⚡</h2>
<p>Alright so in this blog post we configured our cluster further.</p>
<p>We exposed the Traefik dashboard and deployed an example application. Of course, now it is time to build on this. The issuing of certificates and deployment of the ingress routes, for example, is something that can be automated as well.</p>
<p>However for now we will leave it to this, and hopefully, you learned enough from it so that you can build out your Kubernetes cluster yourself. In the future, I will definitely post some more about it.</p>
<p>See you next time! 👋</p>
<p><strong>Sources used for this post</strong>:</p>
<ul>
<li><a href="https://kubernetes.io/docs/home/">Kubernetes Docs</a></li>
<li><a href="https://cert-manager.io/docs/">cert-manager Docs</a></li>
</ul>
]]></content></item><item><title>Kubernetes with Terraform &amp; Traefik V2 + cert-manager | Part 1</title><link>https://vonsopanen.github.io/posts/kubernetes-with-terraform-traefik-v2-cert-manager-part-1/</link><pubDate>Sat, 21 Nov 2020 06:28:07 +0100</pubDate><guid>https://vonsopanen.github.io/posts/kubernetes-with-terraform-traefik-v2-cert-manager-part-1/</guid><description>Introduction 📌 Today we are setting up a managed Kubernetes cluster &amp;amp; load balancer on DigitalOcean using Terraform. Our cluster will be powered with Traefik v2 as our Ingress controller and cert-manager to provide us with free Let&amp;rsquo;s Encrypt certificates.
Woaw. That&amp;rsquo;s a mouth full. Well don&amp;rsquo;t worry, it sounds more difficult than it actually is!
In this part, we&amp;rsquo;ll go over the Kubernetes set-up first, and then in Part 2 we will do the deployments.</description><content type="html"><![CDATA[<h2 id="introduction-">Introduction 📌</h2>
<p>Today we are setting up a managed Kubernetes cluster &amp; load balancer on DigitalOcean using Terraform. Our cluster will be powered with Traefik v2 as our Ingress controller <strong>and</strong> cert-manager to provide us with free Let&rsquo;s Encrypt certificates.</p>
<p>Woaw. That&rsquo;s a mouth full. Well don&rsquo;t worry, it sounds more difficult than it actually is!</p>
<p>In this part, we&rsquo;ll go over the Kubernetes set-up first, and then in Part 2 we will do the deployments. 👏</p>
<blockquote>
<p>Article experience level: <strong>Intermediate</strong></p>
</blockquote>
<p>I categorize every article based on complexity. It&rsquo;s a good way to indicate how well you can follow along with the article since it determines how deep I will explain certain concepts.</p>
<p><strong>Prerequisites</strong></p>
<ul>
<li>Terraform &gt; 0.13 installed</li>
<li>Digital Ocean account</li>
</ul>
<p>👉 <a href="https://github.com/rafrasenberg/kubernetes-terraform-traefik-cert-manager">The Github repo for this blog post</a></p>
<h2 id="infrastructure-as-code-iac-">Infrastructure as Code (IaC) 🚧</h2>
<p>Back in the day, managing IT infrastructure was a tough job. Sysadmins had to manually configure and manage all the hardware and software that was needed for applications to run.</p>
<p>In recent years, this has changed. Cloud computing has vastly improved and it changed the way organizations design, develop, and maintain their IT infrastructure.</p>
<h4 id="what-is-iac">What is IaC?</h4>
<p><em>IaC according to Wikipedia:</em></p>
<p>Infrastructure as code is the process of managing and provisioning computer data centers through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.</p>
<p>A little complex and full of buzzwords, so let&rsquo;s rewrite that into something short and understandable:</p>
<blockquote>
<p>Infrastructure as code (IaC) means to manage your IT infrastructure using configuration files.</p>
</blockquote>
<p>Before IaC, IT personnel would have to manually change configurations to manage their infrastructure. With IaC, your infrastructure’s configuration takes the form of a code file.</p>
<p>Since it’s just text, it’s easy for you to edit, copy, and distribute it. You can <strong>and should</strong> put it under source control, like any other source code file.</p>
<p><img src="/images/blog/6/infrastructure-as-code.png" alt="Infastructure as Code"></p>
<p><a href="https://www.softobiz.com/infrastructure-as-code-an-essential-devops-practice/">Image source</a></p>
<p>The benefits of Infrastructure as Code are:</p>
<ul>
<li>Faster development</li>
<li>More consistency</li>
<li>Accountability</li>
<li>Higher efficiency</li>
<li>Lower costs</li>
</ul>
<p>In this blog post, we will use the famous IaC tool, Terraform. So let&rsquo;s start! 🚀</p>
<h2 id="choosing-the-cloud-provider-">Choosing the cloud provider 🐟</h2>
<p>For this blog post, we are picking a managed Kubernetes cluster on Digital Ocean, since it is perfect to just start out and explore Kubernetes.</p>
<p>It&rsquo;s a cheaper alternative than AWS EKS since launching a managed cluster + load balancer will only cost you around ~$30 per month whereas AWS EKS will set you back at least $75 per month ($0.10 / hour). And this excludes the Load Balancer, NAT gateway etc.</p>
<p>So for just hacking around, I prefer Digital Ocean as it is an easy and inexpensive way to get started. But for critical production environments, I would not advise using Digital Ocean because compared to AWS EKS it doesn&rsquo;t really compete when looking at flexibility, scalability, and maturity.</p>
<p>You don&rsquo;t want to pay? I get it! If you sign up <a href="https://m.do.co/c/52031fcadf3c">through this link</a>, you will get $100 worth of credit for free. Which means 3 full months of free Kubernetes! ❤️</p>
<h2 id="iac-with-terraform">IaC with Terraform</h2>
<p>From this point on I am going to assume you have Terraform &gt; 0.13 installed and you have set-up your Digital Ocean account.</p>
<h4 id="what-is-terraform">What is Terraform?</h4>
<p>Terraform is a tool for building, changing, and versioning infrastructure safely and efficiently. Terraform can manage existing, popular service providers as well as custom solutions. ✅</p>
<p>The infrastructure Terraform can manage includes low-level components such as compute instances, storage, and networking, as well as high-level components such as DNS entries, SaaS features, etc.</p>
<h2 id="getting-started-with-terraform">Getting started with Terraform</h2>
<p>Alright, so the first thing we are going to do is prepare our workspace. Let&rsquo;s create a folder and <code>cd</code> into it.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ mkdir do-k8-config &amp;&amp; cd do-k8-config
</code></pre><p>The first file we are going to create is <code>01-backend.tf</code>. This will basically hold the main configuration files and will tell us which version of Terraform to use and which providers to use.</p>
<p>A provider is responsible for understanding API interactions and exposing resources. Most providers configure a specific infrastructure platform (either cloud or self-hosted).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#66d9ef">terraform</span> {
  required_version <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;~&gt; 0.13.5&#34;</span>
  <span style="color:#66d9ef">required_providers</span> {
    digitalocean <span style="color:#f92672">=</span> {
      source  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;digitalocean/digitalocean&#34;</span>
      version <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;~&gt; 2.0.2&#34;</span>
    }
  }
}
</code></pre></div><p>Next up is creating the <code>terraform.tfvars</code> file. This will hold all the variables of the infrastructure. Terraform automatically loads the variables in this file when running the <code>terraform apply</code> command, without needing the specify the <code>-var-file=&quot;foo.tfvars&quot;</code> flag.</p>
<p>Best practices when working with larger codebases would be to split this variable file into several variable files each corresponding to a certain part of your configuration. But for the simplicity of this blog post, we will store all of it in one file.</p>
<p>The first variable we need to specify is the API token of Digital Ocean. This is needed so Terraform can communicate through the Digital Ocean provider.</p>
<p>To get the Digital Ocean API token, log in, and find your account settings. Generate one if you hadn&rsquo;t already. Then replace the variable below with your token.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># 1 Backend variables
</span><span style="color:#75715e"></span>do_token                              <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;478a6caadc70293857235kshdglkjshasgklasg7cb643525asdgcd1&#34;</span>

</code></pre></div><p>Now we create the <code>provider.tf</code> file.</p>
<p>Terraform configurations must declare which providers they require so that Terraform can install and use them. Additionally, some providers require configuration (like endpoint URLs or cloud regions) before they can be used.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># Register the DO token
</span><span style="color:#75715e"></span><span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;do_token&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Digital Ocean token.&#34;</span>
}<span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># Configure the DigitalOcean Provider
</span><span style="color:#75715e"></span><span style="color:#66d9ef">provider</span> <span style="color:#e6db74">&#34;digitalocean&#34;</span> {
  token <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">do_token</span>
}
</code></pre></div><p>Your current folder structure should look like this right now:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">.
└── do-k8-config/
    ├── 01-backend.tf
    ├── provider.tf
    └── terraform.tfvars
</code></pre><h2 id="configuring-the-cluster">Configuring the cluster</h2>
<p>Next up is our cluster configuration. Create a file and name it <code>02-cluster.tf</code>. In there we first declare the variables that we are going to use. Some variables that we are declaring here are the cluster name, the region and the node size.</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># Variable declaration
</span><span style="color:#75715e"></span><span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;cluster_name&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cluster name that will be created.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;cluster_region&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cluster region.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;cluster_tags&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">list</span>(<span style="color:#66d9ef">string</span>)
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cluster tags.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;node_size&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;The size of the nodes in the cluster.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;node_max_count&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Maximum amount of nodes in the cluster.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;node_min_count&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">number</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Minimum amount of nodes in the cluster.&#34;</span>
}
</code></pre></td></tr></table>
</div>
</div><p>Next up is the actual cluster configuration and the connection to the Kubernetes and Helm (the package manager) providers.</p>
<p>If you really want to dive more into Terraform configuration, I highly suggest to check out the docs of each provider, since it is too much to go over all the config settings here in this blog. The docs are really good!</p>
<ul>
<li><a href="https://registry.terraform.io/providers/digitalocean/digitalocean/latest/docs">Digital Ocean Provider Docs</a></li>
<li><a href="https://registry.terraform.io/providers/hashicorp/helm/latest/docs">Helm Provider Docs</a></li>
<li><a href="https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs">Kubernetes Provider Docs</a></li>
</ul>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">63
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">64
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">65
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">66
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">67
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">68
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">69
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">70
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">71
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># Enable auto upgrade patch versions
</span><span style="color:#75715e"></span><span style="color:#66d9ef">data</span> <span style="color:#e6db74">&#34;digitalocean_kubernetes_versions&#34; &#34;do_cluster_version&#34;</span> {
  version_prefix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1.19.&#34;</span>
}<span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># Create the cluster with autoscaling on
</span><span style="color:#75715e"></span><span style="color:#66d9ef">resource</span> <span style="color:#e6db74">&#34;digitalocean_kubernetes_cluster&#34; &#34;do_cluster&#34;</span> {
  name         <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">cluster_name</span>
  region       <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">cluster_region</span>
  auto_upgrade <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
  version      <span style="color:#f92672">=</span> <span style="color:#66d9ef">data</span>.<span style="color:#66d9ef">digitalocean_kubernetes_versions</span>.<span style="color:#66d9ef">do_cluster_version</span>.<span style="color:#66d9ef">latest_version</span>
  tags         <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">cluster_tags</span>

  <span style="color:#66d9ef">node_pool</span> {
    name       <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;${var.cluster_name}-pool&#34;</span>
    size       <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">node_size</span>
    min_nodes  <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">node_min_count</span>
    max_nodes  <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">node_max_count</span>
    auto_scale <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
  }
}<span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># Load and connect to Kubernetes
</span><span style="color:#75715e"></span><span style="color:#66d9ef">provider</span> <span style="color:#e6db74">&#34;kubernetes&#34;</span> {
  version          <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;~&gt; 1.13.3&#34;</span>
  load_config_file <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
  host             <span style="color:#f92672">=</span> <span style="color:#66d9ef">digitalocean_kubernetes_cluster</span>.<span style="color:#66d9ef">do_cluster</span>.<span style="color:#66d9ef">endpoint</span>
  token            <span style="color:#f92672">=</span> <span style="color:#66d9ef">digitalocean_kubernetes_cluster</span>.<span style="color:#66d9ef">do_cluster</span>.<span style="color:#66d9ef">kube_config</span>[<span style="color:#ae81ff">0</span>].<span style="color:#66d9ef">token</span>
  cluster_ca_certificate <span style="color:#f92672">=</span> <span style="color:#66d9ef">base64decode</span>(
    <span style="color:#66d9ef">digitalocean_kubernetes_cluster</span>.<span style="color:#66d9ef">do_cluster</span>.<span style="color:#66d9ef">kube_config</span>[<span style="color:#ae81ff">0</span>].<span style="color:#66d9ef">cluster_ca_certificate</span>
  )
}<span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># Load and connect to Helm
</span><span style="color:#75715e"></span><span style="color:#66d9ef">provider</span> <span style="color:#e6db74">&#34;helm&#34;</span> {
  <span style="color:#66d9ef">kubernetes</span> {
    load_config_file <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>
    host             <span style="color:#f92672">=</span> <span style="color:#66d9ef">digitalocean_kubernetes_cluster</span>.<span style="color:#66d9ef">do_cluster</span>.<span style="color:#66d9ef">endpoint</span>
    token            <span style="color:#f92672">=</span> <span style="color:#66d9ef">digitalocean_kubernetes_cluster</span>.<span style="color:#66d9ef">do_cluster</span>.<span style="color:#66d9ef">kube_config</span>[<span style="color:#ae81ff">0</span>].<span style="color:#66d9ef">token</span>
    cluster_ca_certificate <span style="color:#f92672">=</span> <span style="color:#66d9ef">base64decode</span>(
      <span style="color:#66d9ef">digitalocean_kubernetes_cluster</span>.<span style="color:#66d9ef">do_cluster</span>.<span style="color:#66d9ef">kube_config</span>[<span style="color:#ae81ff">0</span>].<span style="color:#66d9ef">cluster_ca_certificate</span>
    )
  }
  version <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;~&gt; 1.3.2&#34;</span>
}
</code></pre></td></tr></table>
</div>
</div><p>Next up is updating our <code>terraform.tfvars</code> file to include the new variables. Specify here things like the region where you want to launch your cluster and the node size. We will be using Digital Ocean&rsquo;s autoscaling feature, so therefore we are specifying the max and min node count as well.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># 1 Backend variables
</span><span style="color:#75715e"></span>do_token                              <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;478a6caadc70293857235kshdglkjshasgklasg7cb643525asdgcd1&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># 2 Cluster variables
</span><span style="color:#75715e"></span>cluster_name                          <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;my-special-cluster-name&#34;</span>
cluster_region                        <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ams3&#34;</span>
cluster_tags                          <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;foo&#34;, &#34;development&#34;</span>]
node_size                             <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;s-1vcpu-2gb&#34;</span>
node_min_count                        <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
node_max_count                        <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</code></pre></div><h2 id="read-set-launch-">Read, set.. LAUNCH! 🚀</h2>
<p>Before we can deploy our cluster, we will need to run the <code>terraform init</code> command.</p>
<p>This will initialize our Terraform workspace. It is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ terraform init
</code></pre><p>As you can see now, a new folder called <code>.terraform</code> is formed, holding the configuration files. Next up is planning our execution plan with the <code>terraform plan</code> command.</p>
<p>The <code>terraform plan</code> command is used to create an execution plan. Terraform performs a refresh, unless explicitly disabled, and then determines what actions are necessary to achieve the desired state specified in the configuration files.</p>
<p>This command is a convenient way to check whether the execution plan for a set of changes matches your expectations without making any changes to real resources or to the state.</p>
<p>The optional <code>-out</code> argument can be used to save the generated plan to a file for later execution with terraform apply, which can be useful when running Terraform in automation.</p>
<p>If Terraform detects no changes to the resource or the root module output values, the Terraform plan will indicate that no changes are required.</p>
<p>So let&rsquo;s create our execution plan! ⚡</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ terraform plan -out=terraform.tfplan
</code></pre><p>If this lead to no errors then everything went well! 😄 You can always check your terminal output so see which changes Terraform is going to apply.</p>
<p>We can now officially deploy our cluster by applying our <code>terraform.tfplan</code> with the following command:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ terraform apply &quot;terraform.tfplan&quot;
</code></pre><p>This will take some minutes to finish. When logging in to Digital Ocean, you can see your cluster will now be up and running. AWESOME!</p>
<p><img src="/images/blog/6/digital-ocean-kubernetes-cluster.png" alt="Digital Ocean Kubernetes Cluster"></p>
<p><strong>NOTE:</strong></p>
<p>The state is now stored locally in <code>terraform.tfstate</code>. When working with Terraform in a team, use of a local file makes Terraform usage complicated because each user must make sure they always have the latest state data before running Terraform and make sure that nobody else runs Terraform at the same time.</p>
<p>In that case, it is better to store this state remote by using remote state. Terraform writes the state data to a remote data store, which can then be shared between all members of a team. So for best practices when working with production code and a team, use remote state. To keep this tutorial a little shorter I am using the default local <code>terraform.tfstate</code></p>
<h2 id="adding-traefik-v2-as-ingress-controller">Adding Traefik v2 as Ingress controller</h2>
<p>Alright with our Kubernetes cluster launched right now, let&rsquo;s add Traefik as our Ingress controller.</p>
<p>Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource.</p>
<p>We will be installing Traefik v2 through the official Helm repository. Helm is a Kubernetes package manager and helps you easily define, install, and upgrade even the most complex Kubernetes applications.</p>
<p>To make Digital Ocean Kubernetes work with the Traefik Helm repository, we need some custom configuration. Create a folder called <code>helm-values</code> and within that folder create a file called <code>traefik.yml</code>.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ mkdir helm-values &amp;&amp; cd helm-values &amp;&amp; touch traefik.yml
</code></pre><p>In this <code>traefik.yml</code> file add the following configuration below. This will make sure everything will work properly with <code>cert-manager</code>, which we will configure later on. It also enables the dashboard and will automatically redirect all traffic to TLS.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">ingressRoute</span>:
  <span style="color:#f92672">dashboard</span>:
    <span style="color:#f92672">enabled</span>: <span style="color:#66d9ef">true</span>
    <span style="color:#f92672">annotations</span>: { <span style="color:#f92672">traefik.ingress.kubernetes.io/router.tls</span>: <span style="color:#e6db74">&#34;true&#34;</span> }

<span style="color:#f92672">ports</span>:
  <span style="color:#f92672">web</span>:
    <span style="color:#f92672">redirectTo</span>: <span style="color:#ae81ff">websecure</span>

<span style="color:#f92672">additionalArguments</span>:
  - <span style="color:#e6db74">&#34;--log.level=INFO&#34;</span>
  - <span style="color:#e6db74">&#34;--entrypoints.websecure.http.tls&#34;</span>
  - <span style="color:#e6db74">&#34;--providers.kubernetesIngress.ingressClass=traefik-cert-manager&#34;</span>
  - <span style="color:#e6db74">&#34;--ping&#34;</span>
  - <span style="color:#e6db74">&#34;--metrics.prometheus&#34;</span>
</code></pre></div><p>Now it is time to configure our Terraform files. Create a file called <code>03-ingress.tf</code>. Like in our previous Terraform files, first declare the variables that we will need:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># Variable declaration
</span><span style="color:#75715e"></span><span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;ingress_gateway_chart_name&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Ingress Gateway Helm chart name.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;ingress_gateway_chart_repo&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Ingress Gateway Helm repository name.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;ingress_gateway_chart_version&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Ingress Gateway Helm repository version.&#34;</span>
}
</code></pre></td></tr></table>
</div>
</div><p>In the following section, we will first create a Kubernetes namespace for our Traefik service and then deploy it through Helm. As you can see in here we also specify the custom <code>traefik.yml</code> config that we created earlier.</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># Create Traefik namespace
</span><span style="color:#75715e"></span><span style="color:#66d9ef">resource</span> <span style="color:#e6db74">&#34;kubernetes_namespace&#34; &#34;ingress_gateway_namespace&#34;</span> {
  <span style="color:#66d9ef">metadata</span> {
    annotations <span style="color:#f92672">=</span> {
      name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;traefik&#34;</span>
    }
    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;traefik&#34;</span>
  }
}<span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># Deploy Ingress Controller Traefik
</span><span style="color:#75715e"></span><span style="color:#66d9ef">resource</span> <span style="color:#e6db74">&#34;helm_release&#34; &#34;ingress_gateway&#34;</span> {
  name      <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">ingress_gateway_chart_name</span>
  chart     <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">ingress_gateway_chart_repo</span>
  namespace <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;traefik&#34;</span>

  values <span style="color:#f92672">=</span> [
    <span style="color:#66d9ef">file</span>(<span style="color:#e6db74">&#34;helm-values/traefik.yml&#34;</span>)
  ]
}
</code></pre></td></tr></table>
</div>
</div><p>At last, we need to update our <code>terraform.tfvars</code> again to enter the new variables.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># 1 Backend variables
</span><span style="color:#75715e"></span>do_token                              <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;478a6caadc70293857235kshdglkjshasgklasg7cb643525asdgcd1&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># 2 Cluster variables
</span><span style="color:#75715e"></span>cluster_name                          <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;my-special-cluster-name&#34;</span>
cluster_region                        <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ams3&#34;</span>
cluster_tags                          <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;foo&#34;, &#34;development&#34;</span>]
node_size                             <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;s-1vcpu-2gb&#34;</span>
node_min_count                        <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
node_max_count                        <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># 3 Ingress variables
</span><span style="color:#75715e"></span>ingress_gateway_chart_name            <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;traefik&#34;</span>
ingress_gateway_chart_repo            <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://helm.traefik.io/traefik&#34;</span>
ingress_gateway_chart_version         <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;9.8.3&#34;</span>
</code></pre></div><p>Now it&rsquo;s time to create our execution plan and deploy our new Ingress controller to our Kubernetes cluster! As a sanity check, this is what your current folder structure should look like:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">.
└── do-k8-config/
    ├── .terraform/
    ├── helm-values/
    │   └── traefik.yml
    ├── 01-backend.tf
    ├── 02-cluster.tf
    ├── 03-ingress.tf
    ├── provider.tf
    ├── terraform.tfstate
    ├── terraform.tfplan
    └── terraform.tfvars
</code></pre><p>Alright with that out of the way, let&rsquo;s create our new plan:</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ terraform plan -out=terraform.tfplan
</code></pre><p>If everything went well, it&rsquo;s time to deploy it!</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ terraform apply &quot;terraform.tfplan&quot;
</code></pre><p>Hoorah, Traefik is deployed!! 🚀</p>
<p>If you check your Digital Ocean dashboard right now and go to the Networking menu, and then the Load Balancers. You&rsquo;ll see a shiny fresh new load balancer there. I hear you thinking, huh? But we didn&rsquo;t deploy that?</p>
<p><img src="/images/blog/6/digital-ocean-load-balancer.png" alt="Digital Ocean Load Balancer"></p>
<p>This is the result of using the managed service by Digital Ocean. Whenever a Kubernetes service is declared as type LoadBalancer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">LoadBalancer</span>
</code></pre></div><p>Then Digital Ocean automatically triggers the creation of that load balancer when you deploy the service. To read more about load balancing on Digital Ocean Kubernetes, <a href="https://www.digitalocean.com/docs/kubernetes/how-to/configure-load-balancers/">follow this link.</a></p>
<h2 id="installing-cert-manager">Installing cert-manager</h2>
<p>The last Terraform configuration that we have to do is that of <code>cert-manager</code>.</p>
<p>Cert-manager builds on top of Kubernetes, introducing certificate authorities and certificates as first-class resource types in the Kubernetes API. This makes it possible to provide &lsquo;certificates as a service&rsquo; to developers working within your Kubernetes cluster.</p>
<p>Let&rsquo;s create a new file called <code>04-cert-manager.tf</code>. Like we did before, first declare the variables:</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># Variable declaration
</span><span style="color:#75715e"></span><span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;cert_manager_chart_name&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cert Manager Helm name.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;cert_manager_chart_repo&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cert Manager Helm repository name.&#34;</span>
}
<span style="color:#66d9ef">variable</span> <span style="color:#e6db74">&#34;cert_manager_chart_version&#34;</span> {
  type        <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>
  description <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Cert Manager Helm version.&#34;</span>
}
</code></pre></td></tr></table>
</div>
</div><p>Then we create a new namespace for <code>cert-manager</code> within Kubernetes and we deploy it through Helm.</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># Create cert manager namespace
</span><span style="color:#75715e"></span><span style="color:#66d9ef">resource</span> <span style="color:#e6db74">&#34;kubernetes_namespace&#34; &#34;cert_manager_namespace&#34;</span> {
  <span style="color:#66d9ef">metadata</span> {
    annotations <span style="color:#f92672">=</span> {
      name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cert-manager&#34;</span>
    }
    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cert-manager&#34;</span>
  }
}<span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># Install helm release Cert Manager
</span><span style="color:#75715e"></span><span style="color:#66d9ef">resource</span> <span style="color:#e6db74">&#34;helm_release&#34; &#34;cert-manager&#34;</span> {
  name       <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">cert_manager_chart_name</span>
  chart      <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">cert_manager_chart_name</span>
  repository <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">cert_manager_chart_repo</span>
  version    <span style="color:#f92672">=</span> <span style="color:#66d9ef">var</span>.<span style="color:#66d9ef">cert_manager_chart_version</span>
  namespace  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cert-manager&#34;</span>

  <span style="color:#66d9ef">set</span> {
    name  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;installCRDs&#34;</span>
    value <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;true&#34;</span>
  }
}
</code></pre></td></tr></table>
</div>
</div><p>Then we need to update our <code>terraform.tfvars</code> again to enter the new variables.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-hcl" data-lang="hcl"><span style="color:#75715e"># 1 Backend variables
</span><span style="color:#75715e"></span>do_token                              <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;478a6caadc70293857235kshdglkjshasgklasg7cb643525asdgcd1&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># 2 Cluster variables
</span><span style="color:#75715e"></span>cluster_name                          <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;my-special-cluster-name&#34;</span>
cluster_region                        <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ams3&#34;</span>
cluster_tags                          <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;foo&#34;, &#34;development&#34;</span>]
node_size                             <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;s-1vcpu-2gb&#34;</span>
node_min_count                        <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
node_max_count                        <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># 3 Ingress variables
</span><span style="color:#75715e"></span>ingress_gateway_chart_name            <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;traefik&#34;</span>
ingress_gateway_chart_repo            <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://helm.traefik.io/traefik&#34;</span>
ingress_gateway_chart_version         <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;9.8.3&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e">
</span><span style="color:#75715e"># 4 Cert manager variables
</span><span style="color:#75715e"></span>cert_manager_chart_name               <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cert-manager&#34;</span>
cert_manager_chart_repo               <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;https://charts.jetstack.io&#34;</span>
cert_manager_chart_version            <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1.0.4&#34;</span>
</code></pre></div><p>And at last, you guessed it right, create our execution plan again!</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ terraform plan -out=terraform.tfplan
</code></pre><p>Now let&rsquo;s deploy cert-manager.</p>
<pre tabindex="0"><code class="language-sh-session" data-lang="sh-session">$ terraform apply &quot;terraform.tfplan&quot;
</code></pre><p>Your Kubernetes cluster is now up and running with Traefik v2 as the Ingress Controller and cert-manager installed, ready to generate free Let&rsquo;s Encrypt certificates for the domains you will later point to your cluster.</p>
<h2 id="conclusion-">Conclusion ⚡</h2>
<p>Alright so we have our Kubernetes cluster up and running and Traefik and cert-manager are installed. Now in Part 2 of this blog, we will configure cert-manager so we will be able to issue free Let&rsquo;s Encrypt certificates.</p>
<p>We will then expose the Traefik dashboard to the internet and deploy a simple example app as well, both running behind the Digital Ocean load balancer and fully TLS encrypted. Exciting!</p>
<p>For Part 2, <a href="https://rafrasenberg.com/posts/using-traefik-as-ingress-controller-on-a-kubernetes-cluster-with-cert-manager-part-2/">follow this link.</a></p>
<p><strong>Sources used for this post</strong>:</p>
<ul>
<li><a href="https://www.terraform.io/docs/index.html">Terraform Docs</a></li>
<li><a href="https://stackify.com/what-is-infrastructure-as-code-how-it-works-best-practices-tutorials/">Stackify Article</a></li>
</ul>
]]></content></item><item><title>Ubuntu 20.04 basic server set-up (beginner tutorial)</title><link>https://vonsopanen.github.io/posts/ubuntu-20.04-basic-server-set-up-beginner-tutorial/</link><pubDate>Sun, 27 Sep 2020 12:24:15 +0200</pubDate><guid>https://vonsopanen.github.io/posts/ubuntu-20.04-basic-server-set-up-beginner-tutorial/</guid><description>Introduction 👇 In two previous blog posts, we explored the ease of deploying serverless functions. These are obviously a great way of removing the hassle of maintaining a server and most of the times also reducing the running costs.
However besides the whole &amp;ldquo;serverless hype&amp;rdquo; we are seeing right now in the tech world, a lot of projects still require a traditional cloud VM.
You might need more flexiblity, your app doesn&amp;rsquo;t work well on a serverless set-up or it just doesn&amp;rsquo;t fit your usecase.</description><content type="html"><![CDATA[<h2 id="introduction-">Introduction 👇</h2>
<p>In two previous blog posts, we explored the ease of deploying serverless functions. These are obviously a great way of removing the hassle of maintaining a server and most of the times also reducing the running costs.</p>
<p>However besides the whole <strong>&ldquo;serverless hype&rdquo;</strong> we are seeing right now in the tech world, a lot of projects still require a traditional cloud VM.</p>
<p>You might need more flexiblity, your app doesn&rsquo;t work well on a serverless set-up or it just doesn&rsquo;t fit your usecase. Luckily for us non-cool folks going <em>server</em> instead of <em>serverless</em> is just as easy! 😄</p>
<p>So let&rsquo;s go over that in this blog post!</p>
<p><strong>Note:</strong> To follow this tutorial I assume you have a terminal available. This can be on your Linux machine, Mac OS or Windows Linux Subsystem.</p>
<h2 id="1-what-are-the-options-">1. What are the options ❓</h2>
<p>There are multiple cloud providers available that offer virtual cloud machines. Some of the most wide known:</p>
<ul>
<li>Digital Ocean</li>
<li>AWS EC2</li>
<li>Vultr</li>
<li>Linode</li>
<li>Kamatera</li>
</ul>
<p>In this post we will use my personal favourite: Digital Ocean! ❤️</p>
<p>Besides being one of my favourite cloud providers, you also get $100 worth of credit for free if you sign up through <a href="https://m.do.co/c/52031fcadf3c">this referral link</a>. Can&rsquo;t get any better than that right?</p>
<p>Exactly, that&rsquo;s what I thought. So let&rsquo;s start! 🔥</p>
<h2 id="2-setting-up-ssh-keys-on-your-machine-">2. Setting up SSH keys on your machine 🔑</h2>
<p>Secure Shell (better known as SSH) is a <strong>cryptographic network protocol</strong> which allows users to securely perform a number of network services over an unsecured network.</p>
<p>SSH keys provide a more secure way of logging into a server with SSH than using a password alone. While a password can eventually be cracked with a brute force attack, SSH keys are nearly impossible to decipher by brute force alone.</p>
<p>Generating a key pair provides you with two long string of characters: <strong>a public and a private key</strong>. You can place the public key on any server, and then unlock it by connecting to it with a client that already has the private key.</p>
<p>When the two match up, the system unlocks. 🔓</p>
<h4 id="i-create-rsa-key-pair">I. Create RSA key pair</h4>
<p>So the first step is creating a key pair on our development machine with the following command:</p>
<pre tabindex="0"><code>$ ssh-keygen -t rsa
</code></pre><p>The terminal prompt will ask you to set a password for the key. Make sure to <strong>always set a password!</strong> If you don&rsquo;t and someone could get unauthorized access to your machine, they could just copy your private key to their own machine and log in to all your servers. So make sure to password protect your key. 🔐</p>
<p>The output will be similar to this:</p>
<pre tabindex="0"><code>Generating public/private rsa key pair.
Enter file in which to save the key (/home/raf/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/raf/.ssh/id_rsa.
Your public key has been saved in /home/raf/.ssh/id_rsa.pub.
The key fingerprint is:
4a:dd:0a:c6:35:4e:3f:ed:27:38:8c:74:44:4d:93:67 raf@a
The key's randomart image is:
+--[ RSA 2048]----+
|          .oo.   |
|         .  o.E  |
|        + .  o   |
|     . = = .     |
|      = S = .    |
|     o + = +     |
|      . o + o .  |
|           . o   |
|                 |
+-----------------+
</code></pre><p>The public key is now located in <code>/home/raf/.ssh/id_rsa.pub</code>. The private key (identification) is now located in <code>/home/raf/.ssh/id_rsa</code>.</p>
<h2 id="3-adding-the-key-to-our-digital-ocean-account--launching-the-droplet-">3. Adding the key to our Digital Ocean account &amp; launching the droplet 📁</h2>
<p>Next up is adding our new key to our Digital Ocean account through their GUI. The benefit of this is that whenever you spin up a droplet, it will automatically copy the key to the new server! Saving you from doing that manually, which makes life easier.</p>
<p>The first thing we have to do is getting our public key. We can do that by running the following command:</p>
<pre tabindex="0"><code>$ cat ~/.ssh/id_rsa.pub
</code></pre><p>The output in your terminal should be a long string of characters. Similar to the one below here. Copy your public key.</p>
<pre tabindex="0"><code>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC/aOIJUaUUiZP0KA4vslD97oNVzVYZAiZTTG2Z3ozis3pnt3ZKL5k/XvdOCyfb449BjsShiQim7h1+/m/HEQNVggOqQpWigMf+Ky+zHbQm9mAy+/PpIYMfbWI29nuBnljA9yPcTAdKQM15KNobWeawz0vxoxrncX88sadfasl3j23SFKGUuFpVHXfd4P4njisXrR8vRh07EoU5xafjXrBPYAIsc1vHpK8SpTvwZFc8NwVq2VoQ2s0ig3Fw0gLTgj7roaDEfCW0KZ6SBkAZEmCsFxTnQF8NDiafupNo9ic09xLijvwwasdlkasdfasl2an3fK4twqRcZuZQiRFIppb3kMFQmVWCXW1Udi2ph79TyEXKvmtEnynY+s9SYcGdDbYnbMKqHCrfD4D2JKWXZmuxt7QkFFGTWJeDTPKynmhfuihqQ84LxIK2Gi8sPhRdcs15Kw5A5ctpz+aqd3WUJl78dyvakIcoTNHG06zxR2X7hpz+8U2DQmort4/Dtb5XO9myE5POevdasCroPHxEslzZShHw6dSztC48j7LJ80mSYhI46Vfk5jiH2gT8IHF3JhxytNxBYwTClBYq0c2+M7o62vCVKRCoKFMomCsfME1TmwnJWOMWfnFqMXwBmanUEqJFldEOSg66+egZ5Ym1gSIdww== rafrasenberg@Rafs-MacBook-Pro.local
</code></pre><p>Now <a href="https://m.do.co/c/52031fcadf3c">sign up for Digital Ocean</a> and set-up your account.</p>
<p>After you have logged into the dashboard, head over to your <strong><em>Settings</em></strong> and click the tab <strong><em>Security</em></strong>. After that click on <strong><em>Add SSH key</em></strong>. This will open up a modal where you can paste the public key in. Make sure to save it.</p>
<p><img src="/images/blog/3/image1.png" alt="Digital Ocean dashboard"></p>
<p>After that click on the button in the top right corner <strong><em>Create</em></strong> and from the dropdown choose <strong><em>Droplet</em></strong>.</p>
<p>DigitalOcean Droplets are Linux-based virtual machines (VMs) that run on top of virtualized hardware. Each Droplet you create is a new server you can use, either standalone or as part of a larger, cloud-based infrastructure.</p>
<p>When adding your droplet, make sure you choose Ubuntu 20.04 as the image and pick the standard $5 plan. When scrolling down make sure you select your SSH key as well, that you previously added in your account and give your server a cool hostname! 🆒</p>
<p>View the GIF below to see the full walkthrough.</p>
<p><img src="/images/blog/3/gif1.gif" alt="Creating Digital Ocean droplet"></p>
<h2 id="4-logging-in-to-our-server-">4. Logging in to our server 🚀</h2>
<p>Alright we have already come far haven&rsquo;t we? Now it is time for the real work!</p>
<p>If everything went well you should see a droplet instance in your Digital Ocean dashboard with the hostname you chose and the IP address that belongs to the droplet. Copy this IP address and fire up a terminal session and run the following command (replace the IP address with yours):</p>
<pre tabindex="0"><code>$ ssh root@167.23.10.37
</code></pre><p>It should ask for a password. This is the password that you set-up for your SSH key in step 2. Accept the warning about host authenticity if it appears. You should now be logged in as the root user on your very own cloud server. How cool is that! 🎉</p>
<p><strong>Note:</strong> Root is the superuser account in Unix and Linux. It is a user account for administrative purposes, and typically has the highest access rights on the system.</p>
<h2 id="5-basic-server-set-up-">5. Basic server set-up 💻</h2>
<p>When you first create a new Ubuntu 20.04 server, you should perform some important configuration steps as part of the basic setup. These steps will increase the security and usability of your server, and will give you a solid foundation for subsequent actions.</p>
<h4 id="i-setting-up-a-basic-firewall">I. Setting up a basic firewall</h4>
<p>Ubuntu 20.04 servers can use the UFW firewall to make sure only connections to certain services are allowed. We can set up a basic firewall very easily using this application.</p>
<p>Applications can register their profiles with UFW upon installation. These profiles allow UFW to manage these applications by name. OpenSSH, the service allowing us to connect to our server now, has a profile registered with UFW.</p>
<p>Before we enable the firewall, make sure that OpenSSH is added to our firewall configuration. Otherwise we won&rsquo;t be able to log back in. Run the following command:</p>
<pre tabindex="0"><code>$ ufw allow OpenSSH
</code></pre><p>Now enable our firewall on start-up:</p>
<pre tabindex="0"><code>$ ufw enable
</code></pre><p>If you check the status of our firewall now with the below command, it should be up and running.</p>
<pre tabindex="0"><code>$ ufw status
</code></pre><p>Currently the firewall is blocking all connections except for SSH, if you install and configure additional services, you will need to adjust the firewall settings to allow traffic in.</p>
<p>Small example: Let&rsquo;s say you want to run a webserver and you want to expose your website to the outside world through SSL. You would need to open up port 443 in order to serve the website, because currently the firewall is blocking all connections. That is as easy as running:</p>
<pre tabindex="0"><code>$ ufw allow 443
</code></pre><p>Make sure to always reload the firewall afterwards for the changes to apply. You can do this by running:</p>
<pre tabindex="0"><code>$ ufw reload
</code></pre><h4 id="ii-changing-the-default-ssh-port">II. Changing the default SSH port</h4>
<p>By default, SSH runs on port 22. To prevent automated bots and malicious users from brute-forcing to your server, we can change the port to something else.</p>
<p>An intelligent attacker would still scan your server to determine open ports and services running on them. However, changing the default SSH port will block thousands of automated attacks that don’t have time to rotate ports when targeting a Linux Server. 😁</p>
<p>You can choose any available port you like, in this example we will use <code>Port 3467</code>. So the first thing we do is making sure our firewall allows this port. As you probably know by now, this can be done with:</p>
<pre tabindex="0"><code>$ ufw allow 3467
</code></pre><p>and then reload the firewall with:</p>
<pre tabindex="0"><code>$ ufw reload
</code></pre><p>Now we need to make an adjustment to our SSH config file and tell it to use our newly chosen port. You can do that by running the below command:</p>
<pre tabindex="0"><code>$ nano /etc/ssh/sshd_config
</code></pre><p>Search for the line that says <code>#Port 22</code>:</p>
<pre tabindex="0"><code>#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::

#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
#HostKey /etc/ssh/ssh_host_ed25519_key
</code></pre><p>Uncomment it and change it to <code>Port 3467</code>. Now save the file by using <code>ctrl + x</code> and then type <code>y</code> to save and exit.</p>
<p>The last thing that we have to do is make sure that we restart the SSH service to apply our new changes. You can do that with the following command:</p>
<pre tabindex="0"><code>$ systemctl restart sshd.service
</code></pre><blockquote>
<p><strong>IMPORTANT:</strong>
Whenever you make changes like this <strong>ALWAYS</strong> double check if you can get back into the server first, before you close your terminal session ❗</p>
</blockquote>
<p>So let&rsquo;s see if we can log back into our server through the new port. When you try the following:</p>
<pre tabindex="0"><code>$ ssh root@167.23.10.37
</code></pre><p>This will result in a host rejection. It&rsquo;s because the <code>ssh</code> command defaults to <code>Port 22</code>, however we obviously changed that and therefore it isn&rsquo;t in use anymore. What we have to do then is specifically set the port in our login command. You can do that like so:</p>
<pre tabindex="0"><code>$ ssh root@167.23.10.37 -p 3467
</code></pre><p>If everything went well, you just logged in through the new port. Now it is safe to close your other terminal session.</p>
<h4 id="iii-disabling-password-authentication">III. Disabling password authentication</h4>
<p>A common practice after you have set-up the server for SSH key access, is disabling the password authentication option. This makes sure only connections with a pair of SSH keys are allowed.</p>
<p>Fortunately for us, Digital Ocean already took care of that because we specified our SSH key at the initalization of the droplet. However if you use a different cloud provider, always make sure to disable that. You can do that in the SSH config file.</p>
<h4 id="iv-more-security-practices">IV. More security practices</h4>
<p>There is a lot more to cover, but the steps we discussed in this blog is the bare minimum what I would recommend when setting up a server. The next obvious step is creating a regular user for daily use.</p>
<p>Security wise, you can take it further by improving your Firewall, setting up services like Fail2Ban, disabling direct root login, etc. I won&rsquo;t bore you with all of that here 💤, but feel free to check out the web for more information about this.</p>
<h2 id="conclusion-">Conclusion ⚡</h2>
<p>Alright, we took a small dive into the world of server configuration.</p>
<p>In the next blog post we will go over the things that you need in order to actually serve a webapp on your server. We will also integrate a basic CI pipeline that connects with our droplet that will automatically deploy our changes after pushing it to Github. So stay tuned for that!</p>
<p>See you next time! 👋</p>
]]></content></item><item><title>Deploying a serverless microservice with Flask &amp; Zappa</title><link>https://vonsopanen.github.io/posts/deploying-a-serverless-microservice-with-flask-zappa/</link><pubDate>Sat, 12 Sep 2020 10:15:46 +0200</pubDate><guid>https://vonsopanen.github.io/posts/deploying-a-serverless-microservice-with-flask-zappa/</guid><description>Intro 👇 In this blog post we are going to take a look at an awesome deployment tool called Zappa. We will deploy a serverless microservice using Flask on AWS in under 3 minutes. Exciting.
Our little microservice will be an API endpoint that returns a dataset of a random person in the form of a JSON response. You can view the source code here. Let&amp;rsquo;s start!
Prerequisites: You need an AWS account AWS CLI set-up on your development machine Virtualenv installed What is Zappa?</description><content type="html"><![CDATA[<h2 id="intro-">Intro 👇</h2>
<p>In this blog post we are going to take a look at an awesome deployment tool called Zappa. We will deploy a <strong>serverless microservice</strong> using Flask on AWS in under 3 minutes. Exciting.</p>
<p>Our little microservice will be an API endpoint that returns a dataset of a random person in the form of a JSON response. You can view the <a href="https://github.com/rafrasenberg/flask-zappa-serverless">source code here</a>. Let&rsquo;s start!</p>
<h4 id="prerequisites">Prerequisites:</h4>
<ul>
<li>You need an AWS account</li>
<li>AWS CLI set-up on your development machine</li>
<li>Virtualenv installed</li>
</ul>
<h2 id="what-is-zappa-">What is Zappa? 🔍</h2>
<p>Zappa is a tool that makes it very easy to build and deploy server-less, event-driven Python applications on AWS Lambda + API Gateway.</p>
<p>Think of it as &ldquo;serverless&rdquo; web hosting for your Python apps. That means infinite scaling, zero downtime, zero maintenance - and at a fraction of the cost of your current deployments.</p>
<h2 id="setting-up-the-project-">Setting up the project ✅</h2>
<p>The first thing we need to do is creating a virtual environment where we install Flask and Zappa. To keep things organised I like to add my <code>src</code> folder that contains the app files inside the virtualenv folder.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#960050;background-color:#1e0010">$</span> virtualenv <span style="color:#f92672">-</span>p python3 persongenerator
<span style="color:#960050;background-color:#1e0010">$</span> cd persongenerator <span style="color:#f92672">&amp;&amp;</span> source bin<span style="color:#f92672">/</span>activate
<span style="color:#960050;background-color:#1e0010">$</span> mkdir src <span style="color:#f92672">&amp;&amp;</span> cd src
<span style="color:#960050;background-color:#1e0010">$</span> pip install flask zappa
</code></pre></div><p>After you have ran the commands above, create a new file called <code>app.py</code> and add the code snippet down below. The Flask code is fairly straight-forward, we create a Flask object and attach a route decorator function to it which defines our path. Which is in this case &ldquo;/&rdquo; and thus the homepage.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> flask <span style="color:#f92672">import</span> Flask
app <span style="color:#f92672">=</span> Flask(__name__)

<span style="color:#a6e22e">@app</span><span style="color:#f92672">.</span>route(<span style="color:#e6db74">&#39;/&#39;</span>)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">index</span>():
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello, world!&#34;</span>, <span style="color:#ae81ff">200</span>

<span style="color:#75715e"># This is for local development</span>
<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    app<span style="color:#f92672">.</span>run()
</code></pre></div><p>You can confirm that your hello world app is working by running <code>flask run</code> and visiting your browser at <code>localhost:5000</code></p>
<p>Alright neat, it&rsquo;s working. Time to deploy!</p>
<h2 id="ready-set-deploy-">Ready, set.. DEPLOY! 🚀</h2>
<p>First make sure that you have created an AWS S3 bucket for this app. You can do so by going to the AWS console and then in the top menu following the link <em><strong>Services</strong></em>. Then under the heading <em><strong>Storage</strong></em> click on the link <em><strong>S3</strong></em>.</p>
<p>Click the <em><strong>Create bucket</strong></em> button and add a bucket.</p>
<p><strong>Note:</strong> This bucket will NOT contain website files, as this is not a static website. So the bucket does not need to be public. I will explain why we need this bucket later in the post.</p>
<p>Create a new file in your project root called <code>zappa_settings.json</code>. This is basically what will hold our Zappa configuration.</p>
<pre tabindex="0"><code>{
    &quot;dev&quot;: {
        &quot;s3_bucket&quot;: &quot;your_s3_bucket&quot;,
        &quot;app_function&quot;: &quot;app.app&quot;
    }
}
</code></pre><p>This defines an environment called &lsquo;dev&rsquo; (later, you may want to add &lsquo;staging&rsquo; and &lsquo;production&rsquo; environments as well). It also defines the name of the S3 bucket we will be deploying to. And at last it points Zappa to a WSGI-compatible function, in this case, our Flask app object.</p>
<p>And now we are ready to deploy! <strong>Wait a minute.. WHAAAATTTT?!</strong> 😱</p>
<p>Yup, not joking. Run the following command:</p>
<pre tabindex="0"><code>$ zappa deploy dev
</code></pre><p>And our microservice is alive. You will see in your command line prompt which URL endpoint. That is quick! 🔥🔥</p>
<p>Alright.. slow down there. What is actually going on behind the scenes when we run the command <code>zappa deploy dev</code>?</p>
<h4 id="zappa-will">Zappa will:</h4>
<ol>
<li>Automatically package up your application and local virtual environment into a Lambda-compatible archive and replace any dependencies with versions precompiled for Lambda</li>
<li>Then it will set up the function handler and necessary WSGI Middleware</li>
<li>Upload the archive to S3</li>
<li>Create and manage the necessary Amazon IAM policies and roles and register it as a new Lambda function</li>
<li>Create a new API Gateway resource, create WSGI-compatible routes for it and link it to the new Lambda function</li>
<li>And at last, delete the archive from your S3 bucket. Handy!</li>
</ol>
<p>Now you know why we need that S3 bucket. It is only used as a temporary tool for the deployment as there are no files in there.</p>
<p>Let&rsquo;s expand our &ldquo;Hello World&rdquo; microservice and create a random person generator in the next part.</p>
<h2 id="creating-a-random-person-generator-">Creating a random person generator 👥</h2>
<p>First, create a file in your project root called <code>functions.py</code>. Here we will add the logic for our app, instead of stuffing it into the Flask view.</p>
<p>I fired up Google and searched for a list of popular first and last names. These I added in two text files called <code>first_name.txt</code> and <code>last_name.txt</code>. You can find these text files in the <a href="https://github.com/rafrasenberg/flask-zappa-serverless">Github repo</a>!</p>
<p>So we need a little function that runs and selects one random name out of one of those text files (since we want a random first name &amp; last name). Let&rsquo;s write the code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">random_line</span>(filename):
    <span style="color:#66d9ef">with</span> open(filename) <span style="color:#66d9ef">as</span> f:
        lines <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>readlines()
        <span style="color:#66d9ef">return</span> random<span style="color:#f92672">.</span>choice(lines)<span style="color:#f92672">.</span>strip()
</code></pre></div><p>The function takes the filename as an argument so that we can re-use it for both the first name and last name text file. So we open the file, pick a random line and return it. I called <code>.strip()</code> on it as well to make sure there are no blank spaces after the name.</p>
<p>Alright cool, so we have a way to get a random first and last name. Now a random address to complete our dataset! I found a JSON file online which contained 300 random addresses. It was in the following format:</p>
<pre tabindex="0"><code>{
    &quot;addresses&quot;: [
        {
            &quot;address1&quot;: &quot;1745 T Street Southeast&quot;,
            &quot;address2&quot;: &quot;&quot;,
            &quot;city&quot;: &quot;Washington&quot;,
            &quot;state&quot;: &quot;DC&quot;,
            &quot;postalCode&quot;: &quot;20020&quot;,
            &quot;coordinates&quot;: {
                &quot;lat&quot;: 38.867033,
                &quot;lng&quot;: -76.979235
            }
        },
        {
            &quot;address1&quot;: &quot;6007 Applegate Lane&quot;,
            &quot;address2&quot;: &quot;&quot;,
            &quot;city&quot;: &quot;Louisville&quot;,
            &quot;state&quot;: &quot;KY&quot;,
            &quot;postalCode&quot;: &quot;40219&quot;,
            &quot;coordinates&quot;: {
                &quot;lat&quot;: 38.1343013,
                &quot;lng&quot;: -85.6498512
            }
        }
        ......
    ]
}
</code></pre><p>So we need to write another function that takes a random address from this array and then afterwards we need a final function that joins these two together.</p>
<p>This code is quite easy so we could technically also write all of this in one function or even directly into the Flask view. However I like to seperate my code into small bits which makes everything re-usable and way more error prone. I stick to that principle no matter the size of the app.</p>
<p>Alright, so we need to open the JSON file in our Python function and then return one random address. We can use the following code for that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">import</span> json

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">random_address</span>(filename):
    <span style="color:#66d9ef">with</span> open(filename) <span style="color:#66d9ef">as</span> f:
        data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
        random_address <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>choice(data[<span style="color:#e6db74">&#39;addresses&#39;</span>])
        <span style="color:#66d9ef">return</span> random_address
</code></pre></div><p>Looks fairly similar to our previous function right? So we open the JSON file and then call <code>json.load</code> which will turn our JSON into a Python dictionary. In order to call <code>random.choice</code> we need to have a list. So we use <code>data['addresses']</code> to get our desired format and finally, we return our random address!</p>
<p>Let&rsquo;s continue with the last function, which will join these two together into one random dataset.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">import</span> json

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_random_person</span>():
    data <span style="color:#f92672">=</span> random_address(<span style="color:#e6db74">&#39;address.json&#39;</span>)
    data[<span style="color:#e6db74">&#39;firstName&#39;</span>] <span style="color:#f92672">=</span> random_line(<span style="color:#e6db74">&#39;first_name.txt&#39;</span>)
    data[<span style="color:#e6db74">&#39;lastName&#39;</span>] <span style="color:#f92672">=</span> random_line(<span style="color:#e6db74">&#39;last_name.txt&#39;</span>)
    <span style="color:#66d9ef">return</span> data
</code></pre></div><p>Here we first get a random address and save this into the variable <code>data</code>. This variable contains our dictionary. We then use a new key as a subscript and assign its value with our <code>random_line()</code> function and thus a random name. Then at last, we return the data.</p>
<p>The full <code>functions.py</code> file will look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">import</span> json

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">random_line</span>(filename):
    <span style="color:#66d9ef">with</span> open(filename) <span style="color:#66d9ef">as</span> f:
        lines <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>readlines()
        <span style="color:#66d9ef">return</span> random<span style="color:#f92672">.</span>choice(lines)<span style="color:#f92672">.</span>strip()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">random_address</span>():
    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#39;address.json&#39;</span>) <span style="color:#66d9ef">as</span> f:
        data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
        random_address <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>choice(data[<span style="color:#e6db74">&#39;addresses&#39;</span>])
        <span style="color:#66d9ef">return</span> random_address

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_random_person</span>():
    data <span style="color:#f92672">=</span> random_address() 
    data[<span style="color:#e6db74">&#39;firstName&#39;</span>] <span style="color:#f92672">=</span> random_line(<span style="color:#e6db74">&#39;first_name.txt&#39;</span>)
    data[<span style="color:#e6db74">&#39;lastName&#39;</span>] <span style="color:#f92672">=</span> random_line(<span style="color:#e6db74">&#39;last_name.txt&#39;</span>)
    <span style="color:#66d9ef">return</span> data
</code></pre></div><p>Now all that is left is updating our <code>app.py</code> file. So here we import the function we made and add an extra Flask endpoint to our microservice. We use the built-in <code>jsonify</code> from Flask to turn our Python dictionary into valid JSON.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> flask <span style="color:#f92672">import</span> Flask
<span style="color:#f92672">from</span> flask <span style="color:#f92672">import</span> jsonify
<span style="color:#f92672">from</span> functions <span style="color:#f92672">import</span> get_full_person
app <span style="color:#f92672">=</span> Flask(__name__)

<span style="color:#a6e22e">@app</span><span style="color:#f92672">.</span>route(<span style="color:#e6db74">&#39;/&#39;</span>)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">index</span>():
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Hello, world!&#34;</span>, <span style="color:#ae81ff">200</span>

<span style="color:#a6e22e">@app</span><span style="color:#f92672">.</span>route(<span style="color:#e6db74">&#39;/random-person&#39;</span>)
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_person</span>():
    data <span style="color:#f92672">=</span> get_full_person()
    <span style="color:#66d9ef">return</span> jsonify(data)

<span style="color:#75715e"># This is for local development</span>
<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    app<span style="color:#f92672">.</span>run()
</code></pre></div><p>Now all that is left is updating our serverless Lambda function with the Zappa update command down below. It will automatically update all the code for us and your new random person endpoint will be available at <em>dev/random-person</em>.</p>
<pre tabindex="0"><code>$ zappa update dev
</code></pre><p>Let&rsquo;s test it quick with <code>curl</code>:</p>
<pre tabindex="0"><code>$ curl 'https://xdsk3y7413.execute-api.eu-central-1.amazonaws.com/dev/random-person'
</code></pre><p>The response:</p>
<pre tabindex="0"><code>{
   &quot;address1&quot;:&quot;8502 Madrone Avenue&quot;,
   &quot;address2&quot;:&quot;&quot;,
   &quot;city&quot;:&quot;Louisville&quot;,
   &quot;coordinates&quot;:{
      &quot;lat&quot;:38.1286407,
      &quot;lng&quot;:-85.8678042
   },
   &quot;firstName&quot;:&quot;Jennifer&quot;,
   &quot;lastName&quot;:&quot;Jenkins&quot;,
   &quot;postalCode&quot;:&quot;40258&quot;,
   &quot;state&quot;:&quot;KY&quot;
}
</code></pre><p>Working like a charm! 😄</p>
<h2 id="conclusion-">Conclusion ⚡</h2>
<p>Alright, now you see how easy it is to deploy serverless microservices with Flask and Zappa!</p>
<p>In my previous blog post we also explored Lambda functions but a deployment tool like Zappa makes it 100x times easier. Next up is adding a custom domain to our microservice, which will be covered in a different post.</p>
<p>See you next time! 👋</p>
]]></content></item><item><title>AWS Lambda function to retrieve Twitter follower count</title><link>https://vonsopanen.github.io/posts/aws-lambda-function-to-retrieve-twitter-follower-count/</link><pubDate>Sat, 29 Aug 2020 09:28:55 +0200</pubDate><guid>https://vonsopanen.github.io/posts/aws-lambda-function-to-retrieve-twitter-follower-count/</guid><description>Intro 👇 One of my goals for this current year is to get more comfortable with AWS and get certified eventually. Therefore I will be trying out different things and blogging about it here.
I am starting out with a quite simple task and that is deploying an AWS Lambda function. In this case an AWS Lambda function that retrieves the count of your current Twitter followers.
Everytime the AWS API endpoint gets called, a Python script will run that will retrieve the current stats from the Twitter API and then returns it in JSON format so it can be easily used across systems.</description><content type="html"><![CDATA[<h2 id="intro-">Intro 👇</h2>
<p>One of my goals for this current year is to get more comfortable with AWS and get certified eventually. Therefore I will be trying out different things and blogging about it here.</p>
<p>I am starting out with a quite simple task and that is deploying an <strong>AWS Lambda function</strong>. In this case an AWS Lambda function that retrieves the count of your current Twitter followers.</p>
<p>Everytime the AWS API endpoint gets called, a Python script will run that will retrieve the current stats from the Twitter API and then returns it in JSON format so it can be easily used across systems.</p>
<p><strong>Disclaimer:</strong> I am not an expert in AWS. So I might not use best practices everywhere.</p>
<h2 id="what-is-an-aws-lambda-function-">What is an AWS Lambda function? 🔶</h2>
<p>From the docs:</p>
<blockquote>
<p>AWS Lambda is a serverless compute service that runs your code in response to events and automatically manages the underlying compute resources for you.</p>
</blockquote>
<p>The code you run on AWS Lambda is called a &ldquo;Lambda function&rdquo;. Lambda <strong>runs your code on high-availability compute infrastructure</strong> and performs all the administration of the compute resources. So for example server and operating system maintenance, capacity provisioning and automatic scaling, code and security patch deployment, and code monitoring and logging.</p>
<p>When you create and deploy your Lambda function, it is always ready to run as soon as you trigger it. These triggers you set-up yourself. Some examples that you can use to trigger your Lambda function:</p>
<ul>
<li>HTTP requests via the Amazon API Gateway</li>
<li>Modifications to objects in Amazon S3</li>
<li>Table updates in Amazon DynamoDB</li>
<li>State transitions in AWS Step Functions</li>
</ul>
<p>In this post we will use the first one, a HTTP request via the Amazon API Gateway.</p>
<h2 id="setting-up-the-base-for-the-function-">Setting up the base for the function 🆒</h2>
<p>In order to set-up the Lambda function you need to create an AWS account. Login using your existing account or sign up for a new account using <a href="https://console.aws.amazon.com/">this link</a>.</p>
<p>After the initial set-up of your account, follow the menu link <em><strong>Services</strong></em>, then under the heading <em><strong>Compute</strong></em> click on the link <em><strong>Lambda</strong></em>.</p>
<p>On the left side you are greeted with a small menu, go to <em><strong>Functions</strong></em>. Here we will create the base of the function and give it a name. Later on we are deploying our actual Python code from the command line using the AWS CLI tool.</p>
<p><img src="/images/blog/1/image1.png" alt="create AWS Lambda function"></p>
<p>Name the function <code>getTwitterFollowerCount</code> and at runtime choose Python 3.8, since we are using Python code later on. AWS Lambda has all the major languages available, so you can easily pick another one in a later stage if you would prefer that.</p>
<p>At the permission section make sure you pick the first option: &ldquo;Create a new role with basic Lambda permissions&rdquo;. Now finalize it and create the actual function by going to the top-right side of the page and click <em><strong>Create Function</strong></em>.</p>
<p>Congrats you have made your first AWS Lambda Function! 🏆</p>
<h2 id="testing-our-new-function-">Testing our new function ✅</h2>
<p>Alrighty, time to test our new function. If everything went correct you will be greeted with a configuration panel of the function you have just made, similar to the one below.</p>
<p><img src="/images/blog/1/image2.png" alt="controlpanel AWS Lambda function"></p>
<p>As you can see in the function code, every function that gets created comes with some boilerplate code that includes a Lambda handler. The Lambda handler is the function in your code, that AWS Lambda can invoke when the service executes your code. For Python the general syntax structure looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handler_name</span>(event, context): 
    <span style="color:#f92672">...</span>
    <span style="color:#66d9ef">return</span> some_value
</code></pre></div><p>You always need to specify a handler, otherwise your function won&rsquo;t run and the deploy build will fail.</p>
<p>As you can see at the function code in the AWS console, the default Lambda handler that got generated when we created the function looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lambda_handler</span>(event, context):
    <span style="color:#66d9ef">return</span> {
        <span style="color:#e6db74">&#39;statusCode&#39;</span>: <span style="color:#ae81ff">200</span>,
        <span style="color:#e6db74">&#39;body&#39;</span>: json<span style="color:#f92672">.</span>dumps(<span style="color:#e6db74">&#39;Hello from Lambda!&#39;</span>)
    }
</code></pre></div><p>Let&rsquo;s see what is going on here. Whenever the Lambda function gets executed, it will run this Python function and then return a <code>statuscode 200</code> and a JSON response saying <code>Hello from Lambda!</code></p>
<p>Time to test this!</p>
<p>Click the <em><strong>Test</strong></em> button at the right top of the function configuration panel. You will see a pop-up like the one below. We can use all the default settings here for this small test. The only thing we need to do is entering <code>testEvent</code> at the &ldquo;Event name&rdquo; field. Once done, click <em><strong>Create</strong></em> at the bottom right.</p>
<p><img src="/images/blog/1/image3.png" alt="test event for AWS Lambda function"></p>
<p>All done. Now all that is left is the actual test of the function. Click the <em><strong>Test</strong></em> button again and look at the output below. As you can see we ran our function and got our JSON response back, neat! 🔥</p>
<p>There is some additional information that is available to us that you can find back in the logs each time you execute a Lambda function. This is for example: the request ID, the time it took to execute the function, the memory usage etc.</p>
<p><img src="/images/blog/1/image4.png" alt="test log AWS Lambda function"></p>
<p>So we created the Lambda function, tested it, now it is time to write our actual Python function that contains the logic for retrieving data from the Twitter API regarding our current follower count.</p>
<h2 id="writing-our-python-code-">Writing our Python code 🐍</h2>
<p>Alright the first thing we do is creating a virtual environment for Python, so that all our packages are contained within this envirnoment and not installed globally. Make sure you have installed <code>virtualenv</code> and <code>pip</code>. There are a lot of resources available on the internet for this, I won&rsquo;t get into that here since it is out of the scope of this blogpost.</p>
<p>So let&rsquo;s create our environment through the command line:</p>
<pre tabindex="0"><code>$ virtualenv -p python3.8 lambda
</code></pre><p>You might have different Python versions running on your machine, therefore we specify the Python version explicitly when creating the virtual environment, so it matches with our Python version of our Lambda function. After creating the env, activate it and <code>cd</code> into it.</p>
<pre tabindex="0"><code>$ source lambda/bin/activate &amp;&amp; cd lambda
</code></pre><p>Now create a <code>src</code> folder within the lambda folder, where we will store our Python code and <code>cd</code> into it.</p>
<pre tabindex="0"><code>$ mkdir src &amp;&amp; cd src
</code></pre><p>To retrieve the actual follower count data we will be using a Python package which acts as a Python wrapper around the Twitter API. You can install it using:</p>
<pre tabindex="0"><code>$ pip install python-twitter
</code></pre><p>Now create a new Python file and start-up VS code (or whatever you prefer):</p>
<pre tabindex="0"><code>$ code lambda_function.py
</code></pre><p>To access the Twitter API you will need an developer account in order to get API credentials. Head over to <a href="https://developer.twitter.com">developer.twitter.com</a> and create one. Now use the following code snippet in your Python file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> twitter

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lambda_handler</span>(event, context):
    CONSUMER_KEY <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;PMRxxgv52052lskdtgsd&#39;</span>
    CONSUMER_SECRET <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;RwiDbasg234lsdSADF235dkAJKIlcGCIcSI&#39;</span>
    ACCESS_TOKEN <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1074466481134323569-ciuXuhDGOIYHfnssaEFCXugPsN&#39;</span>
    ACCESS_TOKEN_SECRET <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;yAIASSldf43efdSXGsj888fghjdffgK68dd&#39;</span>
    SCREEN_NAME <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;rafrasenberg&#39;</span>

    <span style="color:#75715e"># Create an Api instance.</span>
    api <span style="color:#f92672">=</span> twitter<span style="color:#f92672">.</span>Api(consumer_key<span style="color:#f92672">=</span>CONSUMER_KEY,
                    consumer_secret<span style="color:#f92672">=</span>CONSUMER_SECRET,
                    access_token_key<span style="color:#f92672">=</span>ACCESS_TOKEN,
                    access_token_secret<span style="color:#f92672">=</span>ACCESS_TOKEN_SECRET)

    data <span style="color:#f92672">=</span> api<span style="color:#f92672">.</span>GetUser(screen_name<span style="color:#f92672">=</span>SCREEN_NAME)


    <span style="color:#66d9ef">return</span> { 
        <span style="color:#e6db74">&#39;followers&#39;</span> : data<span style="color:#f92672">.</span>followers_count
    }
</code></pre></div><p>Make sure to replace the variables with your credentials (I used fake credentials in this post, obviously) and Twitter handle. The Python code is quite simple, let me explain shortly what is going on here:</p>
<ol>
<li>We create an API instance with the credentials</li>
<li>We use the <code>GetUser</code> API endpoint to get data based on the Twitter handle</li>
<li>From the JSON response that we get from Twitter, we get the amount of followers of a user with <code>data.followers_count</code></li>
<li>We wrap this API call in a <code>lambda_handler</code> and return our own JSON response</li>
</ol>
<p>So the Python code is working, now back to our Lambda function!</p>
<h2 id="aws-lambda-deployment-package-through-aws-cli-">AWS Lambda deployment package through AWS CLI 🔁</h2>
<p>Make sure you have AWS CLI set-up on your machine to continue with this part. <a href="https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html">Check out the docs</a> to see how to install it on different operating systems, I won&rsquo;t be going over that here.</p>
<p>Because we have external dependencies in our Python code (The Twitter API wrapper), we need to turn it into a deployment package. This is required anytime you are using the Lambda API to manage functions, or if you need to include libraries and dependencies other than the AWS SDK. A deployment package is a ZIP archive that contains your function code and dependencies.</p>
<p>So what we want to do first is zip all the site-packages of our Python code. First check your folder structure, on my machine the base folder (the virtual environment with the src files) is located in <code>~/Development/lambda</code>. When running the command below, replace all the <code>~/Development/lambda</code> parts, with the correct path of your own machine.</p>
<pre tabindex="0"><code>$ cd ~/Development/lambda/lib/python3.8/site-packages &amp;&amp; zip -r9 ~/Development/lambda/src/function.zip . &amp;&amp; cd ~/Development/lambda/src
</code></pre><p>If everything went well, you have a freshly generated <code>function.zip</code> file now in the <code>src</code> folder. 😄 All that is left right now is adding the function code to our archive, by running the command below.</p>
<pre tabindex="0"><code>$ zip -g functions.zip lambda_function.py
</code></pre><p>Great! 🏆 Now we have a binary ZIP package that is ready to be deployed to Lambda. What we will do is run an update command. We will use the Lambda function that we created earlier through the AWS console and update that. We use the AWS CLI command <code>aws lambda update-function-code</code> for that. We add two arguments, the name of the function, which is <code>getTwitterFollowerCount</code> and the location of the ZIP deployment package.</p>
<p><strong>Note:</strong> If you named your Lambda function differently in the AWS Console earlier, make sure you change this command as well to match the correct name.</p>
<pre tabindex="0"><code>$ aws lambda update-function-code --function-name getTwitterFollowerCount --zip-file fileb://function.zip
</code></pre><p>After running the above command you will receive a JSON response similar to the one below.</p>
<pre tabindex="0"><code>{
    &quot;FunctionName&quot;: &quot;getTwitterFollowerCount&quot;,
    &quot;FunctionArn&quot;: &quot;arn:aws:lambda:eu-central-1:001533050737:function:getTwitterFollowerCount&quot;,
    &quot;Runtime&quot;: &quot;python3.8&quot;,
    &quot;Role&quot;: &quot;arn:aws:iam::001533050737:role/service-role/getTwitterFollowerCount-role-m8vxr9y6&quot;,
    &quot;Handler&quot;: &quot;lambda_function.lambda_handler&quot;,
    &quot;CodeSize&quot;: 4996597,
    &quot;Description&quot;: &quot;&quot;,
    &quot;Timeout&quot;: 3,
    &quot;MemorySize&quot;: 128,
    &quot;LastModified&quot;: &quot;2020-08-29T11:47:52.701+0000&quot;,
    &quot;CodeSha256&quot;: &quot;0HPUHFxNWqu6xLl2NistRBoHp6FEBvnBFXnRXjfomXA=&quot;,
    &quot;Version&quot;: &quot;$LATEST&quot;,
    &quot;TracingConfig&quot;: {
        &quot;Mode&quot;: &quot;PassThrough&quot;
    },
    &quot;RevisionId&quot;: &quot;6c16c627-d4e2-4057-b38d-94cb16395f2f&quot;,
    &quot;State&quot;: &quot;Active&quot;,
    &quot;LastUpdateStatus&quot;: &quot;Successful&quot;
}
</code></pre><h2 id="setting-up-the-api-gateway">Setting up the API Gateway</h2>
<p>The final step we have to take is setting up an API endpoint, so we can actually call our function through a HTTP call. Go back to the AWS console and the function configuration panel. Click the <em><strong>Add trigger</strong></em> button.</p>
<p><img src="/images/blog/1/image5.png" alt="test log AWS Lambda function"></p>
<p>In the following screen use the settings below and click the button <em><strong>Add</strong></em>.</p>
<p><img src="/images/blog/1/image6.png" alt="test log AWS Lambda function"></p>
<blockquote>
<h3 id="done-">DONE! 🔥🏆</h3>
</blockquote>
<p>All that is left now is checking what our actual HTTP endpoint is and test it, to see if everything works as it should. Check out the API Gateway at the bottom of the dashboard and expand it by pressing <em><strong>Details</strong></em>. As you can see we can find the API endpoint there.</p>
<p><img src="/images/blog/1/image7.png" alt="test log AWS Lambda function"></p>
<p>Fire up the command line and use something like <code>curl</code> to test for the response.</p>
<pre tabindex="0"><code>$ curl 'https://4k1g4gaqz2.execute-api.eu-central-1.amazonaws.com/default/getTwitterFollowerCount'
</code></pre><p>If everything went well, you just received a nice JSON response with your current follower count!</p>
<pre tabindex="0"><code>$ {
  &quot;followers&quot;: 18311
}
</code></pre><p>Easy peasy, lemon squeezy. You now have a serverless AWS Lambda function running that you can call from anywhere you want without the need of any server. Awesome.</p>
<p>See you next time. 👋</p>
]]></content></item></channel></rss>